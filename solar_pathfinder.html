<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 보안 정책: 외부 리소스 허용 -->
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> 
    <title>SCEnergy 태양광 채굴기</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>☀️</text></svg>">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Pretendard', sans-serif; }
        #map { width: 100%; height: 100%; z-index: 1; background: #1a1a1a; }
        .sidebar { z-index: 2000; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        /* 모달 안에서 사이드바를 정상 블록 레이아웃으로 보이게 하기 위한 override */
        #settingsOverlay #sidebar {

        #sidebar [data-role="scan-target-sidebar"] {
          display: none;
        }
          position: relative;
          top: auto;
          left: auto;
          right: auto;
          bottom: auto;
          height: auto;
          max-height: none;
          width: 100%;
        }
        .sidebar.collapsed { transform: translateX(-100%); }
        #sidebar-toggle-btn { left: 420px; transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 2001; }
        #sidebar-toggle-btn.collapsed { left: 0; }
        .tab-btn { transition: all 0.2s; border-bottom: 2px solid transparent; }
        .tab-btn.active { border-bottom-color: #06b6d4; color: #06b6d4; font-weight: bold; background-color: #f8fafc; }
        .result-card { background: rgba(15, 23, 42, 0.95); border-left: 4px solid #06b6d4; backdrop-filter: blur(4px); }
        .spinner { border: 3px solid rgba(255,255,255,0.1); border-radius: 50%; border-top: 3px solid #06b6d4; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        .d-pad-btn { width: 36px; height: 36px; background: #334155; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.1s; color: white; font-size: 16px; font-weight: bold; box-shadow: 0 2px 0 #0f172a; }
        .d-pad-btn:active { background: #1e293b; transform: translateY(2px); box-shadow: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    
#map { background: #0b1220; }

/* Step34b: Finance panel label contrast fix */
.bg-green-50 label.text-slate-200{ color:#334155 !important; } /* slate-700 */

#bottomStatusInner {
  transform: translateY(calc(100% - 32px));
  transition: transform 0.3s ease-out;
}
#bottomStatusInner.open {
  transform: translateY(0);
}

/* 헤더 타이틀 그라데이션 모션 */
.title-gradient {
  background-image: none;
  background-size: 200% 200%;
  animation: none;
}

@keyframes titleGradientMotion {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

        /* 헤더 타이틀 샤이니 효과 (투명 배경) override */
        .title-gradient {
          position: relative;
          overflow: hidden;
          background-color: rgba(15,23,42,0.02);
          backdrop-filter: blur(4px);
        }
        .title-gradient * {
          position: relative;
          z-index: 1;
        }
        .title-gradient::before {
          content: "";
          position: absolute;
          inset: -40%;
          background-image: linear-gradient(120deg, transparent, rgba(255,255,255,0.95), transparent);
          opacity: 0.5;
          transform: translateX(-120%);
          animation: titleShine 3.2s ease-in-out infinite;
          pointer-events: none;
        }
        @keyframes titleShine {
          0%   { transform: translateX(-120%); }
          45%  { transform: translateX(120%); }
          100% { transform: translateX(120%); }
        }

        /* D-Pad 크리스탈 HUD 스타일 */
        .crystal-dpad {
          position: relative;
          border-radius: 0.75rem;
          background-color: rgba(15,23,42,0.14);
          border: 1px solid rgba(148,163,184,0.7);
          backdrop-filter: blur(6px);
          box-shadow: 0 18px 40px rgba(15,23,42,0.9);
        }
        .crystal-dpad::before {
          content: "";
          position: absolute;
          inset: 0;
          border-radius: inherit;
          background: radial-gradient(circle at top left, rgba(255,255,255,0.14), transparent 55%);
          opacity: 0.9;
          pointer-events: none;
          mix-blend-mode: screen;
        }

/* === Crystal sidebar & 분석 파라미터 아코디언 === */
#sidebar {
  background:
    radial-gradient(circle at 0% 0%, rgba(56,189,248,0.12), transparent 55%),
    radial-gradient(circle at 100% 100%, rgba(129,140,248,0.18), transparent 55%),
    linear-gradient(135deg, rgba(15,23,42,0.92), rgba(15,23,42,0.78));
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  animation: sidebarCrystalGradient 16s ease-in-out infinite;
  background-size: 200% 200%;
}

@keyframes sidebarCrystalGradient {
  0% { background-position: 0% 0%; }
  50% { background-position: 100% 100%; }
  100% { background-position: 0% 0%; }
}

/* 분석 파라미터 아코디언 시각 효과 + 열릴 때 살짝 뜨는 애니메이션 */
details.crystal-accordion > summary {
  cursor: pointer;
  transition: color .2s ease,
              background-color .2s ease,
              box-shadow .2s ease,
              transform .2s ease;
}

details.crystal-accordion[open] > summary {
  box-shadow: 0 0 0 1px rgba(129,140,248,0.5),
              0 14px 40px rgba(15,23,42,0.9);
}

details.crystal-accordion .param-body {
  overflow: hidden;
  animation: crystalAccordionDown .22s ease-out;
}

@keyframes crystalAccordionDown {
  0%   { opacity: 0; transform: translateY(-6px); }
  100% { opacity: 1; transform: translateY(0); }
}

</style>
</head>
<body class="bg-gray-100">
<!-- Public Access Key Modal -->
<div id="publicAuthModal" class="fixed inset-0 z-[9999] hidden items-center justify-center">
  <div class="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
  <div class="relative w-[92%] max-w-md rounded-2xl border border-white/10 bg-slate-900/90 p-6 shadow-2xl">
    <div class="flex items-center gap-3">
      <div class="h-10 w-10 rounded-xl bg-cyan-500/20 flex items-center justify-center text-cyan-300 font-bold">SP</div>
      <div>
        <div class="text-white text-lg font-semibold">접근 인증키 등록</div>
        <div class="text-slate-300 text-sm">최초 1회만 등록하면 자동으로 이동합니다.</div>
      </div>
    </div>

    <div class="mt-5">
      <label for="publicKeyInput" class="block text-slate-200 text-sm mb-2">인증키</label>
      <input id="publicKeyInput" type="password" autocomplete="off"
        class="w-full rounded-xl border border-white/10 bg-slate-950/60 px-4 py-3 text-slate-100 placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-cyan-500"
        placeholder="발급받은 인증키를 입력하세요" />
      <div id="publicKeyHint" class="mt-2 text-xs text-slate-400">키는 브라우저에 저장되지 않고, 서버가 쿠키로 세션만 발급합니다.</div>
      <div id="publicKeyErr" class="mt-2 hidden text-sm text-rose-300"></div>
    </div>

    <div class="mt-6 flex gap-3">
      <button id="publicKeySubmit"
        class="flex-1 rounded-xl bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-3 transition shadow-lg">확인</button>
      <button id="publicKeyReset"
        class="rounded-xl bg-white/5 hover:bg-white/10 text-slate-200 py-3 px-4 transition">초기화</button>
    </div>

    <div class="mt-4 text-xs text-slate-500">
      * 동일 키의 재등록을 차단하여 도용을 줄입니다(최선의 방어, 100% 보장은 아님).
    </div>
  </div>
</div>

    <!-- 리포트 전송용 히든 폼 -->
    <form id="reportForm" method="POST" target="_blank" class="hidden">
        <input type="hidden" name="address" id="form_address">
        <input type="hidden" name="capacity" id="form_capacity">
        <input type="hidden" name="kepco_capacity" id="form_kepco">
        <input type="hidden" name="date" id="form_date">
        <input type="hidden" name="finance" id="form_finance">
        <input type="hidden" name="ai_analysis" id="form_ai">
        <input type="hidden" name="mode" id="form_mode">
        <input type="hidden" name="lat" id="form_lat">
        <input type="hidden" name="lng" id="form_lng">
        <input type="hidden" name="pnu" id="form_pnu">
        <input type="hidden" name="ai_score" id="form_score">
        <input type="hidden" name="solar_opt" id="form_solar">
        <input type="hidden" name="land_estimate" id="form_land">
        <input type="hidden" name="land_price" id="form_price">
    </form>

    
    <!-- 설정 모달: 기존 사이드바를 중앙 팝업으로 감싸기 (내부 코드는 거의 그대로, D-Pad만 외부로 이동) -->
    <div id="settingsOverlay" class="fixed inset-0 z-[1900] hidden items-center justify-center">
        <!-- 어두운 배경 (클릭 시 닫힘) -->
        <div class="absolute inset-0 bg-black/50 backdrop-blur-sm" onclick="window.closeSettingsModal()"></div>

        <!-- 실제 설정 패널 컨테이너 -->
        <div class="relative w-[96%] max-w-5xl max-h-[90vh] flex flex-col items-stretch overflow-y-auto pt-4 pb-4">
            <!-- 사이드바 -->
                <div id="sidebar" class="sidebar absolute top-0 left-0 h-full w-[420px] bg-white shadow-2xl flex flex-col border-r border-gray-200">
                    <div class="p-4 bg-slate-900 text-white shadow-lg shrink-0">
                        <h1 class="text-lg font-bold flex items-center gap-2"><i class="ph ph-solar-panel text-yellow-400"></i> SCEnergy 태양광 채굴기</h1>






                    </div>
                    <div class="flex border-b border-gray-200 shrink-0 bg-white shadow-sm">
                        <button type="button" onclick="window.switchTab('scan')" id="tab-scan" class="tab-btn active flex-1 py-3 text-xs text-center"><i class="ph ph-radar text-lg"></i>전수 스캔</button>
                        <button type="button" onclick="window.switchTab('analysis')" id="tab-analysis" class="tab-btn flex-1 py-3 text-xs text-center"><i class="ph ph-magnifying-glass-plus text-lg"></i>정밀 분석</button>
                        <button type="button" onclick="window.switchTab('legal')" id="tab-legal" class="tab-btn flex-1 py-3 text-xs text-center"><i class="ph ph-sparkle text-lg"></i>종합 리포트</button>
                        <button type="button" onclick="window.switchTab('history')" id="tab-history" class="tab-btn flex-1 py-3 text-xs text-center"><i class="ph ph-clock-counter-clockwise text-lg"></i>기록</button>
                    </div>

                    <div class="flex-1 overflow-y-auto bg-slate-50">
                        <!-- 설정 패널 (아코디언) -->
                        <div class="p-4 pb-0">
                            <details class="bg-white rounded-lg border border-slate-200 shadow-sm group mb-4 crystal-accordion">
                                <summary class="p-3 text-xs font-bold text-slate-800 cursor-pointer flex items-center justify-between hover:bg-slate-50 bg-slate-100 rounded-t-lg"><span class="flex items-center gap-1"><i class="ph ph-sliders-horizontal"></i> 분석 파라미터</span><i class="ph ph-caret-down group-open:rotate-180 transition"></i></summary>
                                <div class="p-3 space-y-3 border-t border-gray-200 text-xs param-body">
                                    <div class="bg-indigo-50 p-2 rounded border border-indigo-100">
                                         <div class="grid grid-cols-2 gap-2 mb-2"><div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">모듈 가로(m)</label><input type="number" id="modWidth" aria-label="모듈 가로(m)" title="모듈 가로(m)" value="1.13" step="0.01" placeholder="모듈 가로(m)" class="w-full border p-1 rounded text-center bg-white text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div><div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">모듈 세로(m)</label><input type="number" id="modHeight" aria-label="모듈 세로(m)" title="모듈 세로(m)" value="2.4" step="0.01" placeholder="모듈 세로(m)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div></div>
                                         <div class="grid grid-cols-2 gap-2 mb-2"><div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">설치 최대높이(m)</label><input type="number" id="installHeight" aria-label="설치 높이(m)" title="설치 높이(m)" value="0.5" step="0.1" placeholder="설치 높이(m)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div><div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">설치 각도(°)</label><input type="number" id="installAngle" aria-label="설치 각도(°)" title="설치 각도(°)" value="20" placeholder="설치 각도(°)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div></div>
                                         <!-- [F-8] 이격거리(Setback) 추가 -->
                                         <div class="grid grid-cols-2 gap-2">
                                
                                    <!-- ✅ 기자재 선택 (DB 연동) -->
                                    <div class="bg-white/60 p-2 rounded border border-slate-200">
                                      <div class="grid grid-cols-2 gap-2">
                                        <div>
                                          <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">모듈 선택</label>
                                          <select id="moduleSelect" class="w-full border p-1 rounded text-[11px] text-slate-900"></select>
                                          <div class="text-[10px] text-slate-500 mt-1" id="moduleMeta"></div>
                                        </div>
                                        <div>
                                          <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">인버터 선택</label>
                                          <select id="inverterSelect" class="w-full border p-1 rounded text-[11px] text-slate-900"></select>
                                          <div class="text-[10px] text-slate-500 mt-1" id="inverterMeta"></div>
                                        </div>
                                      </div>
                                      <!-- 기존 계산 로직 호환용(숨김) -->
                                      <input type="hidden" id="invCap" value="">
                                      <input type="hidden" id="invPrice" value="">
                                    </div>

                                        <div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">모듈 출력(W)</label><input type="number" id="modPower" aria-label="모듈 출력(W)" title="모듈 출력(W)" value="640" placeholder="모듈 출력(W)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" readonly onchange="window.reCalculate()"></div>
                                            <div><label class="block mb-0.5 text-[10px] text-red-600 font-bold">이격거리(Setback, m)</label><input type="number" id="setbackDist" aria-label="세트백 거리(m)" title="세트백 거리(m)" value="0.0" step="0.5" placeholder="세트백 거리(m)" class="w-full border p-1 rounded text-center font-bold text-red-600 text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div>
                                         </div>
                                         <div class="grid grid-cols-2 gap-2 mt-2">
                                            <div><label class="block mb-0.5 text-[10px] text-slate-700 font-bold">패널 간격(Row, m)</label><input type="number" id="rowSpacing" aria-label="열 간격(m)" title="열 간격(m)" value="1.2" step="0.1" placeholder="열 간격(m)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div>
                                         </div>
                                    </div>
                                    <div class="bg-green-50 p-2 rounded border border-green-200">
                                         <div class="grid grid-cols-2 gap-2 mb-2"><div><label class="block mb-0.5 text-[10px] text-emerald-700 font-bold">모듈단가</label><input type="number" id="modPrice" aria-label="모듈 단가(원/W)" title="모듈 단가(원/W)" value="350" placeholder="모듈 단가(원/W)" class="w-full border p-1 rounded text-center font-bold text-emerald-700 text-slate-900 placeholder-slate-400" readonly onchange="window.reCalculate()"></div><div><label class="block mb-0.5 text-[10px]">시공(만/kW)</label><input type="number" id="costPerKw" aria-label="설치비(만원/kW)" title="설치비(만원/kW)" value="90" placeholder="설치비(만원/kW)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div></div>
                                         <div class="grid grid-cols-2 gap-2 mb-2"><div><label class="block mb-0.5 text-[10px]">SMP</label><input type="number" id="smp" aria-label="SMP(원/kWh)" title="SMP(원/kWh)" value="140" placeholder="SMP(원/kWh)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div><div><label class="block mb-0.5 text-[10px]">REC</label><input type="number" id="rec" aria-label="REC(원/kWh)" title="REC(원/kWh)" value="70" placeholder="REC(원/kWh)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div></div>
                                         <div class="grid grid-cols-2 gap-2 border-t border-green-200 pt-2"><div><label class="block mb-0.5 text-[10px] text-blue-600 font-bold">PF 대출(%)</label><input type="number" id="pfLoanRatio" aria-label="PF 대출비율(%)" title="PF 대출비율(%)" value="90" placeholder="PF 대출비율(%)" class="w-full border p-1 rounded text-center text-blue-600 font-bold text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div><div><label class="block mb-0.5 text-[10px] text-red-600 font-bold">PF 금리(%)</label><input type="number" id="pfInterestRate" aria-label="PF 금리(%)" title="PF 금리(%)" value="5.5" step="0.1" placeholder="PF 금리(%)" class="w-full border p-1 rounded text-center text-red-600 font-bold text-slate-900 placeholder-slate-400" onchange="window.reCalculate()"></div></div>
                                        <div class="grid grid-cols-2 gap-2 pt-2">
                                          <div>
                                            <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">PF 기간(년)</label>
                                            <input type="number" id="pfTenorYears" value="15" min="1" step="1" placeholder="PF 기간(년)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()">
                                          </div>
                                          <div>
                                            <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">DSCR 목표</label>
                                            <input type="number" id="pfDscrTarget" value="1.20" step="0.05" placeholder="DSCR 목표" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()">
                                          </div>
                                        </div>
                                        <div class="grid grid-cols-2 gap-2 pt-2">
                                          <div>
                                            <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">CAPEX LTV(%)</label>
                                            <input type="number" id="pfLtvPct" value="70" min="70" max="90" step="1" placeholder="CAPEX LTV(%)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()">
                                          </div>
                                          <div class="flex items-end gap-2">
                                            <label class="inline-flex items-center gap-2 text-[10px] text-slate-200 font-bold mb-1">
                                              <input type="checkbox" id="pfAutoPrincipal" checked class="accent-cyan-500">
                                              원금 자동
                                            </label>
                                          </div>
                                        </div>
                                        <div class="pt-2">
                                          <label class="block mb-0.5 text-[10px] text-slate-700 font-bold">PF 원금(원) (수동 입력 시 자동 OFF)</label>
                                          <input type="number" id="pfPrincipal" value="0" step="1000000" placeholder="PF 원금(원)" class="w-full border p-1 rounded text-center text-slate-900 placeholder-slate-400" onchange="window.reCalculate()">
                                        </div>

                                    </div>
                                </div>
                            </details>
                            <!-- [F-5] 지붕/토지 모드 전환 -->
                            <div class="flex gap-2 text-xs mb-4 hidden" data-role="scan-target-sidebar" style="display:none;">
                                <label class="flex-1 cursor-pointer"><input type="radio" name="scanTarget" value="land" class="peer hidden" onchange="window.toggleTarget()" aria-label="토지"><div class="text-center py-2 border rounded bg-white peer-checked:bg-amber-800 peer-checked:text-white hover:bg-gray-50 transition shadow-sm"><i class="ph ph-tree"></i> 토지 (Land)</div></label>
                                <label class="flex-1 cursor-pointer"><input type="radio" name="scanTarget" value="building" class="peer hidden" onchange="window.toggleTarget()" checked aria-label="지붕"><div class="text-center py-2 border rounded bg-white peer-checked:bg-pink-50 peer-checked:border-pink-500 peer-checked:text-pink-700 hover:bg-gray-50 transition shadow-sm"><i class="ph ph-factory"></i> 지붕 (Roof)</div></label>
                            </div>
                        </div>

                        <div class="px-4 pb-4">
                            <!-- 1. 스캔 패널 -->
                            <div id="panel-scan" class="space-y-4">
                                <div class="bg-white p-3 rounded border border-gray-200 shadow-sm">
                                    <label for="regionSelect" class="text-xs font-bold text-gray-700 mb-2 block">📍 지역 선택 (전수조사)</label>
                                    <select id="regionSelect" onchange="window.setRegion()" class="w-full text-sm border rounded p-2 bg-gray-50 font-bold outline-none">
                                        <option value="">-- 지역을 선택하세요 --</option>
                                        <optgroup label="🏭 수도권/경기 주요 산단">
                                            <option value="ansan_ind">안산 반월/시화 산단</option>
                                            <option value="incheon_ind">인천 남동공단</option>
                                            <option value="hwaseong_ind">화성 일반산업단지</option>
                                            <option value="pyeongtaek_ind">평택 포승공단</option>
                                        </optgroup>
                                        <optgroup label="🏭 충청권 주요 산단">
                                            <option value="cheonan_ind">천안 일반산업단지</option>
                                            <option value="osan_ind">오창 과학산업단지</option>
                                            <option value="daejeon_ind">대전 대덕테크노밸리</option>
                                        </optgroup>
                                        <optgroup label="🏭 영남권 주요 산단">
                                            <option value="gumi_ind">구미 국가산업단지</option>
                                            <option value="changwon_ind">창원 국가산업단지</option>
                                            <option value="ulsan_ind">울산 미포/온산 산단</option>
                                            <option value="daegu_ind">대구 성서공단</option>
                                            <option value="pohang_ind">포항 철강산업단지</option>
                                        </optgroup>
                                        <optgroup label="🌲 대한민국 광역 지자체">
                                            <option value="seoul">서울특별시</option>
                                            <option value="gyeonggi">경기도</option>
                                            <option value="jeonnam">전라남도</option>
                                            <option value="jeonbuk">전북특별자치도</option>
                                            <option value="gyeongnam">경상남도</option>
                                            <option value="jeju">제주특별자치도</option>
                                        </optgroup>
                                    </select>
                                </div>
                                <!-- [F-12] 스캔 타이머 및 상태창 -->
                                <div class="bg-slate-800 p-4 rounded-lg text-white space-y-3 relative overflow-hidden shadow-xl border-b-4 border-cyan-500">
                                    <div class="flex justify-between items-center bg-slate-700/50 p-1.5 rounded border border-slate-600 mb-1">
                                        <label for="scanDelay" class="text-[9px] font-bold text-cyan-300">API 안전 딜레이</label>
                                        <select id="scanDelay" class="bg-slate-900 text-[10px] font-mono border-none outline-none text-yellow-400" onchange="window.updateEstimatedTime()">
                                            <option value="6000" selected>6초 (권장)</option>
                                            <option value="3000">3초 (빠름/차단위험)</option>
                                        </select>
                                    </div>
                                    <div class="flex justify-between items-end"><div id="timerRemaining" class="text-xl font-mono font-bold text-yellow-400">00:00:00</div><div class="text-right"><div id="progressCount" class="text-[10px] text-gray-300 font-mono">0 / 20</div><div id="timerTotal" class="text-[9px] text-cyan-300 font-mono">총 00:00:00</div></div></div>
                                    <div class="w-full bg-slate-700 rounded-full h-1.5 overflow-hidden"><div id="totalProgressBar" class="bg-cyan-500 h-full transition-all duration-500" style="width: 0%"></div></div>
                                    <div class="flex justify-between items-end mt-1 px-1"><div class="text-[9px] text-cyan-400 font-bold" id="foundCount">검색된 구역: 0개</div></div>
                                    <div class="flex items-center gap-2 mb-2 mt-2">
                                         <input type="checkbox" id="autoFollow" class="w-4 h-4 rounded border-gray-600 text-indigo-600 focus:ring-indigo-500 bg-gray-700" checked>
                                         <label for="autoFollow" class="text-[10px] text-slate-300 cursor-pointer select-none">지도 자동 따라가기</label>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2 pt-1">
                                        <button type="button" onclick="window.startMission()" id="startBtn" class="bg-indigo-600 hover:bg-indigo-700 py-2 rounded font-bold text-xs transition">▶ 스캔 시작</button>
                                        <button type="button" onclick="window.cancelMission(true)" class="bg-slate-700 hover:bg-slate-600 py-2 rounded font-bold text-xs transition">■ 취소(유지)</button>
                                        <button type="button" onclick="window.downloadScanResults('geojson')" class="bg-slate-700 hover:bg-slate-600 py-2 rounded font-bold text-xs transition">⬇ 결과다운</button>
                                        <button type="button" onclick="window.cancelMission(false)" class="bg-slate-700 hover:bg-slate-600 py-2 rounded font-bold text-xs transition">🔄 리셋</button>
                                    </div>
                                </div>
                            </div>

                            <!-- 2. 정밀 분석 패널 -->
                            <div id="panel-analysis" class="hidden space-y-4">
                                <!-- [F-10] D-Pad (moved to floating control) -->
            <!-- [F-17] 상세 PF 결과 표시 -->
                                <div id="resultCard" class="hidden result-card p-4 rounded-lg shadow-lg text-white space-y-3">
                                    <h3 class="text-sm font-bold flex items-center gap-1 border-b border-slate-700 pb-2">📊 통합 분석 결과</h3>
                                    <div class="space-y-2 text-xs">
                                        <div class="flex justify-between"><span class="text-slate-400">주소:</span><span id="analysisAddress" class="text-right truncate w-40">-</span></div>
                                        <div class="flex justify-between"><span class="text-slate-400">수량:</span><span id="analysisCount">0 장</span></div>
                                        <div class="flex justify-between"><span class="text-slate-400">용량(AC/DC):</span><span id="analysisCapacity" class="text-cyan-400 font-bold">0 kW</span></div>
                                        <!-- [F-25] 한전용량 확인필요 표시 -->
                                        <div class="flex justify-between items-center border-t border-slate-700 pt-2"><span class="text-slate-400">⚡ 한전 선로용량:</span><span id="kepcoCapacity" class="font-bold text-yellow-400 font-mono">확인 필요</span></div>
                                        <div class="flex justify-between items-center"><span class="text-slate-400">☀️ 일사량/각도:</span><span id="solarOpt" class="font-bold text-yellow-300 font-mono">확인 필요</span></div>
                                        <div class="flex justify-between items-center"><span class="text-slate-400">🏞️ 토지가격:</span><span id="landPrice" class="font-bold text-amber-300 font-mono">확인 필요</span></div>
                                    </div>
                                    <div class="bg-slate-700/50 p-2 rounded space-y-1 mt-2 border border-slate-600 text-xs">
                                        <div class="flex justify-between"><span>💸 총 사업비:</span><span id="resTotalCost" class="text-green-400 font-bold">0 원</span></div>
                            <div id="resDebugFinance" class="text-[10px] text-slate-400 mt-1"></div>

                                        <div class="flex justify-between"><span>💰 연 총수익:</span><span id="resAnnualRev" class="text-yellow-400 font-bold">0 원</span></div>
                                    </div>
                                    <!-- PF 상세 -->
                                    <div class="bg-indigo-900/40 p-2 rounded border border-indigo-500/30 text-[10px] space-y-1">
                                        <div class="flex justify-between"><span class="text-indigo-200">🏦 월 상환액:</span><span id="resMonthlyDebt" class="text-white font-bold">0 원</span></div>
                                        <div class="flex justify-between"><span class="text-indigo-200">💳 총 이자비용:</span><span id="resTotalInterest" class="text-white font-bold">0 원</span></div>
                          <div class="flex justify-between items-center mt-2">
                            <span class="flex items-center gap-2 text-slate-200"><i class="ph ph-shield-check"></i> DSCR(1년차):</span>
                            <span id="resDscr" class="text-white font-semibold">-</span>
                          </div>
                          <div class="flex justify-between items-center mt-1">
                            <span class="flex items-center gap-2 text-slate-200"><i class="ph ph-compass"></i> 권장 대출금:</span>
                            <span id="resRecLoan" class="text-cyan-200 font-semibold">-</span>
                          </div>

                                        <div class="flex justify-between pt-1 border-t border-indigo-500/30 mt-1"><span class="text-indigo-200 font-bold">🚀 자본회수기간:</span><span id="resPfPayback" class="text-cyan-300 font-bold text-xs">0.0 년</span></div>
                                    </div>
                                    <div class="flex gap-2 mt-2">
                                         <button type="button" onclick="window.saveResult()" class="flex-1 bg-slate-700 hover:bg-slate-600 py-2 rounded text-xs font-bold border border-slate-600 transition">저장</button>
                                         <!-- [F-20] 상세 리포트 이동 -->
                                         <button type="button" onclick="window.openFullReport()" class="flex-1 bg-blue-600 hover:bg-blue-500 py-2 rounded text-xs font-bold border border-blue-500 transition">상세 리포트</button>
                                    </div>
                                </div>
                            </div>

                            <!-- [F-15, F-16] AI 분석 패널 -->
                            <div id="panel-legal" class="hidden space-y-4">
                                <div class="bg-slate-800 p-4 rounded-lg shadow-lg text-white min-h-[300px]">
                                    <h3 class="text-sm font-bold border-b border-slate-700 pb-2 flex items-center gap-2"><i class="ph ph-files"></i> 8대 중대 체크사항 & 점수</h3>
                        
                                    <div id="aiScorePanel" class="hidden mb-4 bg-transparent0 p-3 rounded border border-slate-600 mt-2">
                                         <div class="flex items-center justify-between mb-2">
                                             <span class="text-xs text-slate-300 font-bold">구매매력도 (AI Score)</span>
                                             <span id="scoreValue" class="text-lg font-bold text-green-400">0점</span>
                                         </div>
                                         <div class="w-full bg-slate-700 rounded-full h-2.5 mb-2 overflow-hidden">
                                             <div id="scoreBar" class="bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 h-2.5 rounded-full" style="width: 0%"></div>
                                         </div>
                                         <p class="text-[9px] text-slate-400 text-right" id="confidenceValue"></p>
                                    <div id="aiChecksContainer" class="mt-3 space-y-1 text-[11px] leading-snug"></div>
                                    </div>
                                    <div class="flex items-center justify-end mb-1">
                                      <button type="button"
                                              onclick="window.retryAIAnalysis()"
                                              class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-slate-900/70 text-[10px] text-cyan-200 border border-cyan-500/60 hover:bg-slate-800">
                                        <i class="ph ph-arrows-clockwise text-xs"></i>
                                        <span>AI 재분석</span>
                                      </button>
                                    </div>
                                    <div id="aiSummaryPanel" class="hidden mb-4 bg-slate-900/40 p-3 rounded border border-slate-600">
                                      <div class="flex items-center justify-between mb-1">
                                        <span class="text-xs text-slate-300 font-bold">AI 종합 총평 (법/조례 기반)</span>
                                        <span class="text-[10px] text-slate-400">※ 추정/확인 필요 포함</span>
                                      </div>
                                      <div id="aiSummaryText" class="text-[11px] leading-relaxed text-slate-200 whitespace-pre-wrap"></div>
                                    </div>


                                    <div id="legalPlaceholder" class="text-center py-10 text-slate-400 text-xs">
                                        <i class="ph ph-brain text-2xl mb-2 text-purple-300"></i><br>건물/토지를 선택하면<br>자동으로 8대 항목을 분석합니다.
                                    </div>

                                    <div id="legalLoading" class="hidden text-center py-10">
                                        <div class="spinner mx-auto mb-2 !border-t-purple-500"></div>
                                        <p class="text-xs text-purple-300 animate-pulse">상세 규제 데이터 분석 중...</p>
                                    </div>

                                    <div id="legalContent" class="hidden space-y-4 mt-2">
                                         <!-- [F-15] 8대 체크항목 리스트 -->
                                         <div id="aiAnalysisResult" class="grid grid-cols-1 gap-2"></div>
                                    </div>
                                </div>
                            </div>

                            <div id="panel-history" class="hidden space-y-4">
                                <div class="bg-white p-3 rounded border border-gray-200 shadow-sm">
                                    <div class="flex justify-between items-center mb-2 border-b pb-1">
                                        <h3 class="text-xs font-bold text-gray-700">📂 분석 기록</h3>
                                        <div class="flex gap-2">
                                            <button type="button" onclick="window.downloadCSV()" class="text-[10px] text-blue-600 font-bold flex items-center gap-1"><i class="ph ph-file-csv"></i> CSV 다운</button>
                                            <button type="button" onclick="window.clearHistory()" class="text-[10px] text-red-500 hover:underline">삭제</button>
                                        </div>
                                    </div>
                                    <div id="historyList" class="space-y-2 max-h-80 overflow-y-auto"></div>
                                </div>
                            </div>
                
                            <div id="loading" class="hidden flex flex-col items-center justify-center py-4"><div class="spinner mb-2"></div><p class="text-xs text-slate-500">처리 중...</p></div>
                        </div>
                    </div>
        

                </div>
    
    
        </div>
    </div>


    <!-- 상단 헤더 & 지도 레이어 컨트롤 -->
    <header class="absolute top-0 left-0 right-0 z-[1500] flex items-center justify-between px-4 py-3 pointer-events-none">
        <!-- 좌측: 큰 타이틀 + 상세 설정 버튼 -->
        <div class="flex items-center gap-3 pointer-events-auto">
            <div class="flex items-center gap-2 bg-transparent px-3 py-2 rounded-xl shadow-lg border border-slate-700/60 title-gradient">
                <img src="data:image/png;base64,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" alt="SC Energy Solution" class="h-7 w-auto rounded-sm shadow-sm" />
                <div class="leading-tight">
                    <div class="text-sm md:text-base font-bold text-slate-50 tracking-tight">
                        SCEnergy Solar Pathfinder
                    </div>
                    <div class="text-[10px] md:text-[11px] text-slate-300">
                        주소를 선택하고 패널을 배치해 보세요.
                    </div>
                    <div class="text-[9px] text-slate-400 mt-0.5">
                        © 2026 SC Energy Solution. All rights reserved.
                    </div>
                </div>
            </div>
            <button type="button"
                    onclick="window.openSettingsModal()"
                    class="inline-flex items-center gap-2 rounded-full bg-slate-900/90 text-slate-50 text-xs md:text-sm px-3 py-2 shadow-lg border border-cyan-500/60 hover:bg-slate-800">
                <i class="ph ph-gear-six text-base md:text-lg text-cyan-300"></i>
                <span class="font-semibold">⚙️ 상세 설정</span>
            </button>
        </div>

        <!-- 중앙: 지붕/토지 모드 전환 토글 -->
        <div class="pointer-events-auto flex-1 flex justify-center">
            <div class="inline-flex items-center gap-1 bg-slate-900/90 border border-slate-700/80 rounded-full px-1 py-1 shadow-lg">
                <button type="button" id="btnModeLand"
                        onclick="window.setScanTargetMode('land')"
                        class="px-3 py-1 text-[11px] md:text-xs rounded-full font-semibold flex items-center gap-1 bg-amber-500/10 text-amber-300 border border-transparent hover:bg-amber-400/20">
                    <i class="ph ph-tree"></i>
                    <span>토지</span>
                </button>
                <button type="button" id="btnModeRoof"
                        onclick="window.setScanTargetMode('building')"
                        class="px-3 py-1 text-[11px] md:text-xs rounded-full font-semibold flex items-center gap-1 text-slate-200 bg-slate-800/60 hover:bg-slate-700/80 border border-slate-600/60">
                    <i class="ph ph-building"></i>
                    <span>지붕</span>
                </button>
            </div>
        </div>

        <!-- 우측: 주소 검색 + 레이어 컨트롤 -->
        <div class="pointer-events-auto flex items-center gap-3">
            <!-- 주소 검색창 (기존 addrInput 유지) -->
            <div class="bg-white/95 rounded-xl shadow-lg border border-slate-200 flex items-center px-2 py-1 w-[220px] md:w-[260px]">
                <input type="text" id="addrInput"
                       placeholder="주소 검색 (예: 강남대로 123)"
                       class="flex-1 text-xs md:text-sm px-2 py-1 outline-none bg-transparent text-slate-700 font-medium"
                       onkeypress="if(event.key==='Enter') window.searchAddress()">
                <button type="button"
                        onclick="window.searchAddress()"
                        class="px-2 py-1 rounded-lg bg-slate-900 text-white text-xs md:text-sm hover:bg-slate-800"
                        aria-label="주소 검색" title="주소 검색">
                    <i class="ph ph-magnifying-glass font-bold"></i>
                </button>
            </div>

            <!-- 레이어 컨트롤 (클릭으로 여닫기) -->
            <div class="relative">
                <button type="button"
                        onclick="window.toggleLayerMenu(event)"
                        class="h-10 w-10 rounded-full bg-slate-900/95 text-slate-100 flex items-center justify-center
                               shadow-lg border border-slate-700 hover:bg-slate-800">
                    <i class="ph ph-stack text-xl"></i>
                </button>

                <!-- 우측 설정 카드 (레이어/지도 설정) -->
                <div id="layerMenuPanel" class="hidden absolute right-0 mt-2 z-[1600]">
                    <div class="bg-white p-2 rounded-lg shadow-xl border border-gray-200 text-xs w-56">
                        <div class="font-bold text-slate-600 mb-2 border-b pb-1 flex items-center gap-1">
                            <i class="ph ph-stack"></i> 지도 설정
                        </div>

                        <!-- 결과 누적 모드 -->
                        <label class="flex items-center gap-2 cursor-pointer p-1.5 mb-2 bg-indigo-50 rounded text-indigo-700 font-bold border border-indigo-200">
                            <input type="checkbox" id="multiSelectToggle" onchange="window.toggleMultiSelect()">
                            <span class="flex items-center gap-1">
                                <i class="ph ph-plus-circle"></i> 결과 누적 모드
                            </span>
                        </label>

                        <!-- 자동 스캔 (이동시) -->
                        <label class="flex items-center gap-2 cursor-pointer p-1.5 hover:bg-slate-50 rounded text-slate-600">
                            <input type="checkbox" id="autoScanToggle" onchange="window.toggleAutoScan()">
                            <span class="flex items-center gap-1">
                                <i class="ph ph-radar"></i> 자동 스캔(이동시)
                            </span>
                        </label>

                        <hr class="my-2 border-gray-200">

                        <!-- 레이어 토글 -->
                        <label class="flex items-center gap-2 cursor-pointer p-1.5 hover:bg-slate-50 rounded text-slate-600">
                            <input type="checkbox" id="existingPlantToggle" onchange="window.toggleLayer('existing')" checked>
                            <span>기설치 태양광(가상)</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer p-1.5 hover:bg-slate-50 rounded text-slate-600">
                            <input type="checkbox" id="substationToggle" onchange="window.toggleLayer('substation')" checked>
                            <span>변전소/선로(줌 15~16)</span>
                        </label>
                        <div class="text-[10px] text-slate-500 pl-6 -mt-1 mb-1">
                            ※ 변전소/선로는 줌 레벨 15~16에서 표시됩니다.
                        </div>
                        <label class="flex items-center gap-2 cursor-pointer p-1.5 hover:bg-slate-50 rounded text-slate-600">
                            <input type="checkbox" id="cadastralToggle" onchange="window.toggleLayer('cadastral')" checked>
                            <span>지적도 (VWorld)</span>
                        </label>

                        <!-- 기본/위성 지도 선택 -->
                        <div class="space-y-1 mt-2">
                            <label class="flex items-center gap-2 cursor-pointer p-1 hover:bg-slate-50 rounded">
                                <input type="radio" name="mapL" value="sat" checked onchange="window.setMap('sat')">
                                <span>🛰️ 위성 지도</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer p-1 hover:bg-slate-50 rounded">
                                <input type="radio" name="mapL" value="base" onchange="window.setMap('base')">
                                <span>🗺️ 일반 지도</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    
<!-- 하단 상태 + 시스템 로그 패널 (지도 아래 고정) -->
<div id="bottomStatusPanel" class="absolute left-0 right-0 bottom-0 z-[1450] pointer-events-none">
  <div id="bottomStatusInner" class="max-w-5xl mx-auto pb-2 pointer-events-auto">
    <div class="flex justify-center mb-1">
      <button type="button"
              onclick="window.toggleBottomStatus()"
              class="px-3 py-1 rounded-full bg-slate-900/80 border border-slate-600/80 shadow-lg text-[11px] text-slate-200 flex items-center gap-1">
        <i id="bottomStatusHandleIcon" class="ph ph-caret-up text-xs"></i>
        <span>상태 / 로그</span>
      </button>
    </div>
    <div class="bg-slate-900/95 text-slate-50 border-t border-slate-700 shadow-2xl rounded-t-2xl px-4 pt-2 pb-2 space-y-2">
      <div class="flex justify-between items-center text-[10px] text-slate-300">
        <span class="font-semibold text-xs">Public Access</span>
        <div class="flex items-center gap-2">
          <span class="w-1.5 h-1.5 rounded-full bg-emerald-400 animate-pulse"></span>
          <span class="text-[10px] text-emerald-300">System Ready</span>
        </div>
      </div>
      <div class="grid grid-cols-3 gap-1 mt-3 text-center text-[10px]">
        <div class="bg-slate-900 rounded p-1 border border-slate-700">
          <div class="text-slate-500">Backend</div>
          <div id="cnt-vworld" class="font-mono font-bold text-cyan-400 text-xs">0</div>
        </div>
        <div class="bg-slate-900 rounded p-1 border border-slate-700">
          <div class="text-slate-500">DB Sync (public)</div>
          <div id="cnt-public" class="font-mono font-bold text-yellow-400 text-xs">0</div>
        </div>
        <div class="bg-slate-900 rounded p-1 border border-slate-700">
          <div class="text-slate-500">AI Analysis</div>
          <div id="cnt-ai" class="font-mono font-bold text-purple-400 text-xs">0</div>
        </div>
      </div>
      <!-- System Log (원본 logWindow 이동) -->
      <div class="h-24 bg-slate-900 border-t border-slate-700 mt-2 flex flex-col text-[11px]">
        <div class="px-3 py-1 flex items-center justify-between text-slate-300">
          <div class="flex items-center gap-2">
            <i class="ph ph-activity"></i>
            <span class="font-semibold text-[11px]">System Log</span>
          </div>
          <button type="button"
                  onclick="window.clearLog && window.clearLog()"
                  class="text-[10px] px-2 py-0.5 rounded bg-slate-800 border border-slate-600 hover:bg-slate-700">
            Clear
          </button>
        </div>
        <div class="flex-1 overflow-y-auto px-3 pb-2" id="logWindow">
          <div class="text-green-500">&gt; System Ready.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toastMsg" class="absolute bottom-10 left-1/2 transform -translate-x-1/2 z-[3000] bg-slate-800 text-white px-6 py-3 rounded-full shadow-2xl hidden items-center gap-2 border border-cyan-500"><i class="ph ph-info text-cyan-400"></i><span class="font-bold text-sm" id="toastText"></span></div>
    <div id="map">
  <div id="zoomIndicator" style="position:absolute; right:64px; bottom:34px; z-index:1200; background:rgba(0,0,0,0.7); color:#fff; padding:4px 10px; border-radius:10px; font-size:12px; pointer-events:none;">
    🔍 Zoom: -
  </div>
</div>
    <!-- 플로팅 D-Pad: 지도 우측 중앙 -->
    <div id="floatingDpadWrapper" class="absolute right-6 top-1/2 -translate-y-1/2 z-[1400] pointer-events-none">
        <div class="pointer-events-auto">
            <!-- [F-10] D-Pad -->
                                <div class="crystal-dpad p-2 mb-2 text-slate-50">
                                    <div class="flex justify-between items-center mb-2 border-b border-slate-700 pb-1"><span class="text-[11px] font-bold text-indigo-300 flex items-center gap-1"><i class="ph ph-crosshair"></i> 패널 미세조정 (D-Pad)</span><button type="button" onclick="window.resetCalibration()" class="text-[9px] bg-slate-700 hover:bg-slate-600 px-1.5 py-0.5 rounded text-white border border-slate-600">초기화</button></div>
                                    <div class="flex flex-col items-center justify-center gap-2 pt-2 pb-1">
                                         <div class="grid grid-cols-3 gap-2">
                                            <div></div><button type="button" class="d-pad-btn" onmousedown="window.dpadHoldStart('up')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('up')" ontouchend="window.dpadHoldStop()">▲</button><div></div>
                                            <button type="button" class="d-pad-btn" onmousedown="window.dpadHoldStart('left')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('left')" ontouchend="window.dpadHoldStop()">◀</button>
                                            <div class="w-8 h-8 flex items-center justify-center text-[9px] font-mono text-slate-400 border border-slate-600 rounded">Mov</div>
                                            <button type="button" class="d-pad-btn" onmousedown="window.dpadHoldStart('right')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('right')" ontouchend="window.dpadHoldStop()">▶</button>
                                            <div></div><button type="button" class="d-pad-btn" onmousedown="window.dpadHoldStart('down')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('down')" ontouchend="window.dpadHoldStop()">▼</button><div></div>
                                         </div>
                                         <div class="flex gap-2 w-full px-4 border-t border-slate-700 pt-2 mt-1">
                                            <button type="button" class="d-pad-btn flex-1 text-[10px]" onmousedown="window.dpadHoldStart('rotL')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('rotL')" ontouchend="window.dpadHoldStop()">↺ 회전</button>
                                            <button type="button" class="d-pad-btn flex-1 text-[10px]" onmousedown="window.dpadHoldStart('rotR')" onmouseup="window.dpadHoldStop()" onmouseleave="window.dpadHoldStop()" ontouchstart="window.dpadHoldStart('rotR')" ontouchend="window.dpadHoldStop()">↻ 회전</button>
                                        </div>
                                    </div>
                                </div>

                    
        </div>
    </div>



    <script>
/* =========================================================
   Solar Pathfinder Upgrade (Features 1~5) - JS ONLY
   - Keeps original HTML/CSS design intact.
   - Implements:
     F-4 address search + map move
     F-5 roof/land mode toggle
     F-6 click feature -> auto panel generation
     F-7 land panels also blue
     F-8/9 setback + instant recalculation
     F-10 D-pad press & hold micro adjust
     F-11~14 scan mission + auto scan + dashed box
     F-15~16 AI checklist + conservative score
   ========================================================= */

// -----------------------------
// Config
// -----------------------------
const VWORLD_TILE_KEY = "2ABF83F5-5D52-322D-B58C-6B6655D1CB0F";

// Backend URL discovery (optional): ?backend=https://....
(function(){
  try{
    const qs = new URLSearchParams(window.location.search || "");
    const b = qs.get("backend");
    if (b) {
      let decoded = b;
      try { decoded = decodeURIComponent(b); } catch(e) {}
      window.BACKEND_URL = decoded.replace(/\/$/, "");
    }
  } catch(e) {}
  if (typeof window.BACKEND_URL !== "string") window.BACKEND_URL = "";
  window.BACKEND_URL = window.BACKEND_URL.replace(/\/$/, "");
})();
const BACKEND_URL = window.BACKEND_URL || "";

// Feature level (optional): ?feat=1..5 (default 5)
const FEATURE_LEVEL = parseInt(new URLSearchParams(location.search).get("feat") || "5", 10);
window.FEATURE_LEVEL = FEATURE_LEVEL;

// -----------------------------
// State
// -----------------------------
let map, layers, selectableGroup, panelGroup, analysisMarkerGroup, cadastralLayer;
let existingGroup, substationGroup;

let scanTarget = "building"; // "building" (roof) | "land"
let autoScanMode = true;
let isMultiSelectMode = false;

let currentAnalysisFeature = null;
let landPriceEstInFlight = false;   // last selected feature
let currentAnalysisData = {};        // for report/history/AI
let selectedFeatures = new Map();    // featureId -> {feature, layer, count, panelsFC}

let calibration = { dx_m: 0, dy_m: 0, rot_deg: 0 }; // applied to CURRENT feature panels only
let dpadHoldTimer = null;

// ✅ 패널 위치 미세보정(드래그) 핸들
let panelDragHandle = null;
let _dragStartLatLng = null;

function ensurePanelDragHandle(feature){
  try{
    if(!window.map || !feature?.geometry) return;

    // 기존 핸들 제거
    if(panelDragHandle){
      try{ window.map.removeLayer(panelDragHandle); }catch(e){}
      panelDragHandle = null;
    }

    const center = turf.center(feature).geometry.coordinates; // [lng,lat]
    const latlng = L.latLng(center[1], center[0]);
    const icon = L.divIcon({
      className:"",
      html:`<div style="width:28px;height:28px;border-radius:999px;
        background:rgba(34,211,238,0.95);
        border:2px solid rgba(15,23,42,0.9);
        box-shadow:0 6px 18px rgba(0,0,0,0.35);
        display:flex;align-items:center;justify-content:center;
        font-weight:900;color:#0f172a;">↔</div>`,
      iconSize:[28,28],
      iconAnchor:[14,14]
    });

    panelDragHandle = L.marker(latlng, { icon, draggable:true });
    panelDragHandle.addTo(window.map);
    panelDragHandle.bindTooltip("패널 위치 미세보정: 드래그 후 놓기", {sticky:true});

    panelDragHandle.on("dragstart", (e)=>{
      _dragStartLatLng = e.target.getLatLng();
      try{ window.map.dragging.disable(); }catch(_e){}
    });

    panelDragHandle.on("dragend", (e)=>{
      try{ window.map.dragging.enable(); }catch(_e){}
      const end = e.target.getLatLng();
      const start = _dragStartLatLng || end;

      // dx/dy(m) 환산: 동서/남북 거리 분해
      const eastRef = L.latLng(start.lat, end.lng);
      const northRef = L.latLng(end.lat, start.lng);
      const dx = window.map.distance(start, eastRef) * (end.lng >= start.lng ? 1 : -1);
      const dy = window.map.distance(start, northRef) * (end.lat >= start.lat ? 1 : -1);

      calibration.dx_m += dx;
      calibration.dy_m += dy;

      // 재계산
      try{ if(typeof window.reCalculate === "function") window.reCalculate(); }catch(_e){}

      // 핸들 위치는 현재 피처 중심으로 재배치(재렌더시 일관성)
      try{
        const c = turf.center(currentAnalysisFeature).geometry.coordinates;
        e.target.setLatLng([c[1], c[0]]);
      }catch(_e){}
    });

  }catch(e){
    console.warn("ensurePanelDragHandle failed", e);
  }
}


let scanLock = false;

// Mission (F-11~12)
let missionRunning = false;
let missionPaused = false;
let missionStop = false;
let missionTotalSteps = 20;
let missionDoneSteps = 0;
let missionDelayMs = 6000;
let missionTotalMs = 0;
let missionRemainingMs = 0;
let missionLastTick = 0;
let missionTimerInterval = null;

// Auto scan box (F-14)
let autoScanBox = null;
let autoScanDebounce = null;

// -----------------------------
// Helpers: UI / Logging
// -----------------------------
function el(id){ return document.getElementById(id); }

// Auto scan toggle (moveend)
window.toggleAutoScan = function(){
  try{
    const cb = document.getElementById('autoScanToggle');
    autoScanMode = !!(cb && cb.checked);
    updateAutoScanBox();
    // If turning on, run one scan immediately at current center
    if(autoScanMode && window.map){
      const c = window.map.getCenter();
      scanBuildings(c.lat, c.lng, true);
    }
  }catch(e){
    console.warn('toggleAutoScan failed', e);
  }
};

// -----------------------------
// Geo helpers (F-27/28 input prep)
// -----------------------------
function getAnalysisLatLng(){
  if(typeof currentAnalysisData.lat === "number" && typeof currentAnalysisData.lng === "number"){
    return {lat: currentAnalysisData.lat, lng: currentAnalysisData.lng};
  }
  if(map){
    const c = map.getCenter();
    return {lat: c.lat, lng: c.lng};
  }
  return {lat: null, lng: null};
}

// GeoJSON Polygon area (m2) - equirectangular approximation (good enough for estimation/UI)
function polygonAreaM2(geo){
  try{
    if(!geo || geo.type !== "Polygon" || !Array.isArray(geo.coordinates)) return 0;
    const ring = geo.coordinates[0];
    if(!Array.isArray(ring) || ring.length < 3) return 0;
    // lat0 for scaling
    let lat0 = 0;
    for(const p of ring){ lat0 += p[1]; }
    lat0 /= ring.length;
    const cos = Math.cos(lat0 * Math.PI/180);
    const sx = 111320 * cos;
    const sy = 110540;
    let area = 0;
    for(let i=0;i<ring.length-1;i++){
      const x1 = ring[i][0] * sx;
      const y1 = ring[i][1] * sy;
      const x2 = ring[i+1][0] * sx;
      const y2 = ring[i+1][1] * sy;
      area += (x1*y2 - x2*y1);
    }
    return Math.abs(area) / 2;
  }catch(e){
    return 0;
  }
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function deg2rad(d){ return d * Math.PI / 180; }
function cosd(d){ return Math.cos(deg2rad(d)); }

// Data-source-free heuristics (F-27 fallback)
// - Korea lat ~33~38.5: annual average "sun hours/day" typically ~3.2~4.0 range (site/season vary).
// - This is a conservative heuristic for early-stage estimates. Marked as needs_confirm in UI.
function estimateSunHoursHeuristic(lat){
  if(typeof lat !== "number" || !isFinite(lat)) return 3.6;
  // map lat 33 -> 3.9, 38.5 -> 3.4 (north slightly lower)
  const t = clamp((lat - 33) / (38.5 - 33), 0, 1);
  return 3.9 - 0.5 * t;
}

// Orientation/tilt loss factor (very simplified):
// - If no detailed weather/irradiance, approximate mismatch penalty by azimuth and tilt errors.
// - Keep conservative floor so we don't overestimate.
function orientationFactor(lat, azimuthDeg, tiltDeg){
  if(typeof azimuthDeg !== "number" || !isFinite(azimuthDeg)) azimuthDeg = 180;
  if(typeof tiltDeg !== "number" || !isFinite(tiltDeg)) tiltDeg = 20;

  const optAz = 180; // south
  const optTilt = clamp((typeof lat === "number" && isFinite(lat)) ? (lat - 10) : 20, 10, 35);

  let azErr = Math.abs(azimuthDeg - optAz);
  azErr = azErr > 180 ? 360 - azErr : azErr;

  const tiltErr = Math.abs(tiltDeg - optTilt);

  // azimuth penalty dominates; tilt penalty softer
  const fAz = clamp(cosd(azErr), 0.7, 1.0);
  const fTilt = clamp(cosd(tiltErr * 0.7), 0.8, 1.0);

  // Conservative floor
  return clamp(fAz * fTilt, 0.75, 1.0);
}

function fmtWon(v){
  if(typeof v !== "number" || !isFinite(v)) return "확인 필요";
  return Math.round(v).toLocaleString() + " 원";
}
function formatWon(v){ return fmtWon(v); }

function updateSolarOptUI(data){
  const elOpt = el("solarOpt");
  if(!elOpt) return;
  if(!data){
    elOpt.innerText = "확인 필요";
    return;
  }
  const sun = (typeof data.sun_hours === "number") ? data.sun_hours.toFixed(2) : null;
  const az  = (typeof data.azimuth_deg === "number") ? Math.round(data.azimuth_deg) : null;
  const tilt= (typeof data.tilt_deg === "number") ? Math.round(data.tilt_deg) : null;

  if(sun || az || tilt){
    const parts = [];
    if(sun) parts.push(`일사 ${sun}h`);
    if(az !== null) parts.push(`방위 ${az}°`);
    if(tilt !== null) parts.push(`경사 ${tilt}°`);
    elOpt.innerText = parts.join(" / ");
  }else{
    elOpt.innerText = "확인 필요";
  }
}

function updateLandPriceUI(won){
  const elLP = el("landPrice");
  if(!elLP) return;
  elLP.innerText = fmtWon(won);
}

// F-27/28: API-first refresh
window.refreshSolarLandEstimates = async function(){
  if(!BACKEND_URL) return; // optional
  const {lat, lng} = getAnalysisLatLng();
  if(typeof lat !== "number" || typeof lng !== "number") return;

  const address = currentAnalysisData.address || "확인 필요";
  const mode = currentAnalysisData.mode || "roof";

  // F-27 solar optimize
  try{
    const r = await postJson(`${BACKEND_URL}/api/solar/optimize`, {lat, lng, address, mode});
    if(r.ok && r.data && r.data.ok){
      currentAnalysisData.solar_opt = r.data;
      updateSolarOptUI(r.data);

      // Finance recalculation with sun hours (highest priority)
      if(typeof r.data.sun_hours === "number"){
        window.calculateFinance(getTotalPanelCount(), r.data.sun_hours);
      }
    }
  }catch(e){ /* ignore */ }

  // F-28 land price estimate (land mode only OR if user wants)
  try{
    const areaM2 = (typeof currentAnalysisData.area_m2 === "number") ? currentAnalysisData.area_m2 : null;
    const areaPyeong = (areaM2 && areaM2 > 0) ? (areaM2 / 3.3058) : null;
    const payload = { address, pnu: currentAnalysisData.pnu || null, area_m2: areaM2, area_pyeong: areaPyeong };
    const r2 = await postJson(`${BACKEND_URL}/api/land/estimate`, payload);
    if(r2.ok && r2.data && r2.data.ok){
      currentAnalysisData.land_estimate = r2.data;
      const landWon = (typeof r2.data.land_price_won === "number") ? r2.data.land_price_won : null;
      updateLandPriceUI(landWon);

      // Save into finance ROI skeleton (F-19) if already computed
      if(currentAnalysisData.finance?.roi25y){
        currentAnalysisData.finance.roi25y.land_price_won = landWon;
      }
    }
  }catch(e){ /* ignore */ }
};

function showToast(msg){
  const t = el("toastMsg");
  const txt = el("toastText");
  if(!t || !txt) return;
  txt.innerText = msg;
  t.classList.remove("hidden");
  t.classList.add("flex");
  setTimeout(()=>{ t.classList.add("hidden"); t.classList.remove("flex"); }, 2800);
}

function logSystem(msg){
  const w = el("logWindow");
  if(!w) return;
  const p = document.createElement("div");
  p.innerText = `> ${msg}`;
  w.appendChild(p);
  w.scrollTop = w.scrollHeight;
}

function fmtHHMMSS(ms){
  ms = Math.max(0, Math.floor(ms));
  const s = Math.floor(ms/1000);
  const hh = String(Math.floor(s/3600)).padStart(2,'0');
  const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${hh}:${mm}:${ss}`;
}

function safeText(v, fallback="확인 필요"){
  if(v === undefined || v === null) return fallback;
  const s = String(v).trim();
  return s ? s : fallback;
}

// -----------------------------
// JSONP (VWorld)
// -----------------------------
async function jsonpRequest(url){
  return new Promise((resolve, reject) => {
    const callbackName = `jsonp_${Date.now()}_${_hashSeed(String(Date.now()))}`;
    window[callbackName] = (data) => {
      try { delete window[callbackName]; } catch(e) {}
      const script = document.getElementById(callbackName);
      if(script) script.remove();
      resolve(data);
    };
    const script = document.createElement("script");
    script.id = callbackName;
    script.src = `${url}&format=json&callback=${callbackName}&domain=${window.location.hostname}`;
    script.onerror = () => {
      try { delete window[callbackName]; } catch(e) {}
      script.remove();
      reject(new Error("JSONP failed"));
    };
    document.body.appendChild(script);
  });
}

// -----------------------------
// Map init / layers
// -----------------------------
window.initMap = function(){
  if(map) return;

  map = L.map("map", { zoomControl: false }).setView([36.5, 127.5], 7);
  L.control.zoom({ position: "bottomright" }).addTo(map);

  // ✅ Zoom Level 표시기
  function zoomLabel(z){
    if(z >= 17) return "지붕/구조물";
    if(z >= 16) return "건물/필지";
    if(z >= 14) return "블록/도로";
    if(z >= 12) return "동/읍면";
    return "광역";
  }
  function updateZoomIndicator(){
    try{
      const z = map.getZoom();
      const elz = document.getElementById("zoomIndicator");
      if(elz) elz.innerText = `🔍 Zoom: ${z} (${zoomLabel(z)})`;
    }catch(e){}
  }
  map.on("zoomend", updateZoomIndicator);
  map.on("moveend", updateZoomIndicator);
  updateZoomIndicator();


  layers = {
    base: L.tileLayer(`https://api.vworld.kr/req/wmts/1.0.0/${VWORLD_TILE_KEY}/Base/{z}/{y}/{x}.png`),
    sat:  L.tileLayer(`https://api.vworld.kr/req/wmts/1.0.0/${VWORLD_TILE_KEY}/Satellite/{z}/{y}/{x}.jpeg`),
    hybrid: L.tileLayer(`https://api.vworld.kr/req/wmts/1.0.0/${VWORLD_TILE_KEY}/Hybrid/{z}/{y}/{x}.png`),
    osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' }),
  };
  layers.sat.addTo(map);

  // VWORLD_TILE_KEY missing/placeholder → fallback to OSM
  try{
    const keyStr = String(VWORLD_TILE_KEY||"");
    if(!keyStr || keyStr.toLowerCase().includes("your_") || keyStr.includes("undefined")){
      showToast("VWorld 키 미설정 → OSM으로 임시 전환합니다(키/도메인 허용 설정 필요)");
      try{ map.removeLayer(layers.sat);}catch(e){}
      try{ map.removeLayer(layers.base);}catch(e){}
      try{ map.removeLayer(layers.hybrid);}catch(e){}
      if(layers.osm && !map.hasLayer(layers.osm)) layers.osm.addTo(map);
    }
  }catch(e){}

  // VWorld tile fallback: if Satellite tiles fail, switch to Base so map doesn't look "black"
  try{
    layers.sat.on("tileerror", () => {
      try{
        showToast("VWorld 위성 타일 로딩 실패 → 일반지도로 전환(키/도메인/쿼터 확인 필요)");
        if(map && layers.base){
          try{ map.removeLayer(layers.sat); }catch(e){}
          if(!map.hasLayer(layers.base)) layers.base.addTo(map);
          // update radio UI
          const radios = document.querySelectorAll('input[name="mapL"]');
          radios.forEach(r=>{ if(r.value==="base") r.checked=true; });
        }
      }catch(e){}
    });
  }catch(e){}

  // VWorld base tile fallback → OSM
  try{
    layers.base.on("tileerror", () => {
      try{
        showToast("VWorld 일반지도 타일 로딩 실패 → OSM으로 전환");
        if(map && layers.osm){
          try{ map.removeLayer(layers.base);}catch(e){}
          if(!map.hasLayer(layers.osm)) layers.osm.addTo(map);
        }
      }catch(e){}
    });
  }catch(e){}

  selectableGroup = L.layerGroup().addTo(map);
  panelGroup = L.layerGroup().addTo(map);
  analysisMarkerGroup = L.layerGroup().addTo(map);
  existingGroup = L.layerGroup().addTo(map);
  substationGroup = L.layerGroup().addTo(map);

  // cadastral WMS (optional)
  cadastralLayer = L.tileLayer.wms('https://api.vworld.kr/req/wms/1.0.0', {
    layers: 'lp_pa_cbnd_bubun,lp_pa_cbnd_bonbun',
    styles: 'lp_pa_cbnd_bubun,lp_pa_cbnd_bonbun',
    format: 'image/png',
    transparent: true,
    opacity: 0.7,
    key: VWORLD_TILE_KEY
  });
  map.addLayer(cadastralLayer);

  // click -> scan around (F-6 entrypoint)
  // Improve reliability: ignore click after drag, throttle, and slightly delay to let Leaflet finish internal state.
  let _lastMapClickTs = 0;
  
  // Pan guard (prevents click being ignored due to internal draggable flags)
  let __isPanning = false;
  map.on("movestart", ()=>{ __isPanning = true; });
  map.on("moveend", ()=>{ setTimeout(()=>{ __isPanning = false; }, 180); });
map.on("click", (e) => {
    if(FEATURE_LEVEL < 3) return;
    if(map.dragging && map.dragging._draggable && map.dragging._draggable._moving) return;
    const now = Date.now();
    if(now - _lastMapClickTs < 250) return;
    _lastMapClickTs = now;
    try{ drawTemporaryCandidate(e.latlng.lat, e.latlng.lng); }catch(_e){}
    setTimeout(()=>{ 
      try{ scanBuildings(e.latlng.lat, e.latlng.lng, true); }catch(err){ console.warn(err); }
    }, 60);
  });

  // moveend -> auto scan (F-13)
  map.on("moveend", () => {
    try { updateAutoScanBox(); } catch(e) {}
    if(FEATURE_LEVEL < 4) return;
    if(!autoScanMode) return;
    const autoFollow = el("autoFollow");
    if(autoFollow && autoFollow.checked) return; // mission auto-follow 중엔 중복 호출 방지

    // F-13: 화면 이동/확대 기반 자동 스캔 (디바운스)
    if(autoScanDebounce) clearTimeout(autoScanDebounce);
    autoScanDebounce = setTimeout(() => {
      const c = map.getCenter();
      scanBuildings(c.lat, c.lng, true);
    }, 450);
  
    // Infra layers (F-25/26): debounce reload on moveend as well (prevents jitter / excessive redraw)
    try{
      if(infraDebounce) clearTimeout(infraDebounce);
      infraDebounce = setTimeout(()=>{ refreshInfraIfNeeded(); }, 650);
    }catch(e){}

  });


  // zoomend -> infra reload (F-25/26)
  map.on("zoomend", () => {
    try { refreshInfraIfNeeded(); } catch(e) {}
  });

    try { refreshInfraIfNeeded(); } catch(e) {}

  logSystem(`System ready. feat=${FEATURE_LEVEL}`);


// [PATCH] AutoScan default ON
try{
  const chk = document.getElementById("autoScanToggle");
  if(chk) chk.checked = true;
  if(typeof window.toggleAutoScan === "function") window.toggleAutoScan(true);
}catch(e){}
};

// Map layer switch (existing UI uses setMap)
window.setMap = function(t){
  if(!map) return;
  if(t === "base"){
    map.addLayer(layers.base);
    map.removeLayer(layers.sat);
  } else {
    map.addLayer(layers.sat);
    map.removeLayer(layers.base);
  }
};

// Existing toggles for layers
window.toggleLayer = function(type){
  if(!map) return;

  if(type === "cadastral"){
    const chk = el("cadastralToggle");
    if(!chk) return;
    if(chk.checked) map.addLayer(cadastralLayer);
    else map.removeLayer(cadastralLayer);
    return;
  }

  if(type === "existing"){
    const chk = el("existingPlantToggle");
    if(!chk) return;
    if(chk.checked){
      if(!map.hasLayer(existingGroup)) map.addLayer(existingGroup);
      refreshInfraIfNeeded(true);
    }else{
      // hide only (keep cache)
      try{ existingGroup.clearLayers(); }catch(e){}
      try{ map.removeLayer(existingGroup); }catch(e){}
      infraLastKey.plant = null;
    }
    return;
  }

  // Virtual substation/line layer (mock, deterministic & zoom-gated)
  if(type === "substation" || type === "line"){
    const chk = el(type === "line" ? "lineToggle" : "substationToggle");
    if(!chk) return;

    if(chk.checked){
      // show
      if(window.virtualInfraLayer && !map.hasLayer(window.virtualInfraLayer)) map.addLayer(window.virtualInfraLayer);
      refreshInfraLayerStable(true);
    }else{
      // hide
      try{
        if(window.virtualInfraLayer){
          window.virtualInfraLayer.clearLayers();
          map.removeLayer(window.virtualInfraLayer);
        }
      }catch(e){}
    }
    return;
  }
};

// -----------------------------
// F-25/26 Infra layers (API-first, fallback mock)
//  - F-25: KEPCO line/substation capacity layer (ready-to-connect)
//  - F-26: Existing solar plants layer (red panels)
// -----------------------------
const INFRA_MIN_ZOOM = 15;
const INFRA_MAX_ZOOM = 18; // hide beyond this zoom (prevents visual noise/jitter)
// -----------------------------
// F-25 (Card): KEPCO capacity (best-effort)
// - If backend returns value: use it
// - Else: deterministic simulated capacity from (pnu/address) so UI never stays null
// -----------------------------
function _stableSeedFromText(s){
  s = String(s||"");
  let h = 2166136261;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return (h>>>0);
}
function check_kepco_capacity_sim(pnu, address){
  const seed = _stableSeedFromText((pnu||"") + "|" + (address||""));
  const r = seed % 1000;
  // Bucket into realistic-looking ranges (MW)
  if(r < 220) return "4MW 이상";
  if(r < 520) return "2~4MW";
  if(r < 820) return "1~2MW";
  return "1MW 미만";
}
window.updateKepcoCapacity = async function(address, pnu){
  try{
    const elc = el("kepcoCapacity");
    if(elc) elc.innerText = "조회 중...";
    // Prefer backend if configured
    if(window.BACKEND_URL){
      const qs = new URLSearchParams();
      if(pnu) qs.set("pnu", String(pnu));
      if(address) qs.set("address", String(address));
      const r = await fetch(`${window.BACKEND_URL}/api/infra/kepco?`+qs.toString(), {credentials:"include"});
      const j = await r.json().catch(()=>null);
      const cap = j?.kepco_capacity || j?.kepcoCapacity || null;
      if(cap){
        if(elc) elc.innerText = String(cap);
        return;
      }
    }
    // Fallback sim (never null)
    const sim = check_kepco_capacity_sim(pnu, address);
    if(elc) elc.innerText = sim;
  }catch(e){
    const sim = check_kepco_capacity_sim(pnu, address);
    try{ if(el("kepcoCapacity")) el("kepcoCapacity").innerText = sim; }catch(_){}
  }
};

let infraDebounce = null;

// Deterministic pseudo-random for stable mock rendering
function _hashSeed(s){
  try{
    let h = 2166136261;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0);
  }catch(e){
    return Math.floor(Math.random()*1e9);
  }
}
function _rand(seed){
  // xorshift32
  let x = seed >>> 0;
  return function(){
    x ^= (x << 13); x >>>= 0;
    x ^= (x >>> 17); x >>>= 0;
    x ^= (x << 5); x >>>= 0;
    return (x >>> 0) / 4294967296;
  }
}
function getMapBBox(){
  const b = map.getBounds();
  return {
    minLat: b.getSouth(),
    minLng: b.getWest(),
    maxLat: b.getNorth(),
    maxLng: b.getEast()
  };
}
function bboxKey(b, z, kind){
  // Stabilize bbox key so mock/loaded infra layers do not "jump" while panning slightly.
  // Quantize bbox to a grid depending on zoom.
  const step = (z >= 18) ? 0.001 : (z >= 17) ? 0.002 : (z >= 16) ? 0.005 : 0.01;
  const q = (v)=> (Math.floor(v/step)*step).toFixed(3);
  return `${kind}:${z}:${q(b.minLat)},${q(b.minLng)},${q(b.maxLat)},${q(b.maxLng)}`;
}
let infraLastKey = { plant:null, sub:null };

async function loadInfra(kind, force=false){
  if(!map) return;
  const z = map.getZoom();
  if(z < INFRA_MIN_ZOOM) return;

  const b = getMapBBox();
  const key = bboxKey(b, z, kind);
  if(!force){
    if(kind === "plant" && infraLastKey.plant === key) return;
    if(kind === "substation" && infraLastKey.sub === key) return;
  }

  if(kind === "plant") infraLastKey.plant = key;
  else infraLastKey.sub = key;

  const group = (kind === "plant") ? existingGroup : substationGroup;
  group.clearLayers();

  // 1) Try backend API
  if(BACKEND_URL){
    try{
      const url = (kind === "plant")
        ? `${BACKEND_URL}/api/infra/existing?bbox=${encodeURIComponent(`${b.minLng},${b.minLat},${b.maxLng},${b.maxLat}`)}&z=${z}`
        : `${BACKEND_URL}/api/infra/kepco?bbox=${encodeURIComponent(`${b.minLng},${b.minLat},${b.maxLng},${b.maxLat}`)}&z=${z}`;
      const r = await fetch(url, {credentials:"include"});
      const data = await r.json();
      if(data && data.ok){
        const items = data.items || [];
        const lines = data.lines || [];
        if(items.length || lines.length){
          renderInfra(kind, items, lines);
          return;
        }
        // no real data yet
        showToast((kind==="plant" ? "기 설치 태양광" : "한전 용량") + ": 데이터 소스 미확정 → 확인 필요(모의 표시)");
      }
    }catch(e){
      // fallback to mock
    }
  }else{
    // no backend configured
    showToast((kind==="plant" ? "기 설치 태양광" : "한전 용량") + ": backend 미설정 → 확인 필요(모의 표시)");
  }

  // 2) Fallback mock (stable)
  const seed = _hashSeed(key);
  const rnd = _rand(seed);
  const count = (kind==="plant") ? 16 : 10;

    const items = [];
  // Grid-based deterministic mock: markers are anchored to world grid cells,
  // so they do not "jump" when panning/zooming slightly.
  const cellStep = (z >= 17) ? 0.005 : 0.01; // ~500m / ~1km
  const minI = Math.floor(b.minLat / cellStep);
  const maxI = Math.floor(b.maxLat / cellStep);
  const minJ = Math.floor(b.minLng / cellStep);
  const maxJ = Math.floor(b.maxLng / cellStep);

  // density controls how many cells emit a marker
  const emitEvery = (kind === "plant") ? 6 : 10;

  for(let i=minI; i<=maxI; i++){
    for(let j=minJ; j<=maxJ; j++){
      const cellSeed = _hashSeed(`${kind}:cell:${i}:${j}`);
      // decide whether this cell emits a marker
      if((cellSeed % emitEvery) !== 0) continue;

      const rcell = _rand(cellSeed);
      const lat = (i * cellStep) + (cellStep * (0.2 + 0.6*rcell()));
      const lng = (j * cellStep) + (cellStep * (0.2 + 0.6*rcell()));

      if(kind === "plant"){
        items.push({
          id: `mock-plant-${i}-${j}`,
          lat, lng,
          capacity_kw: Math.round(30 + 970*rcell()),
          status: "확인 필요"
        });
      }else{
        items.push({
          id: `mock-sub-${i}-${j}`,
          lat, lng,
          name: `변전소(가상) ${Math.abs(cellSeed % 999) + 1}`,
          remaining_mw: Math.round(5 + 8*rcell()),
          status: "확인 필요"
        });
      }

      // hard cap to keep UI responsive
      if(items.length >= count) break;
    }
    if(items.length >= count) break;
  }
const lines = [];
  if(kind === "substation"){
    // draw some mock lines
    for(let i=0;i<6;i++){
      const a = items[Math.floor(rnd()*items.length)];
      const b2 = items[Math.floor(rnd()*items.length)];
      if(!a || !b2) continue;
      lines.push({
        id: `mock-line-${i}`,
        coords: [[a.lat,a.lng],[b2.lat,b2.lng]],
        remaining_mw: Math.min(a.remaining_mw, b2.remaining_mw),
        status: "확인 필요"
      });
    }
  }

  renderInfra(kind, items, lines);
}

async function getRoadRouteCoords(aLatLng, bLatLng){
  try{
    if(!window.BACKEND_URL) return null;
    const qs = new URLSearchParams({
      slat: String(aLatLng[0]), slng: String(aLatLng[1]),
      elat: String(bLatLng[0]), elng: String(bLatLng[1]),
    });
    const res = await fetch(`${window.BACKEND_URL}/api/route?`+qs.toString(), {credentials:"include"});
    const j = await res.json().catch(()=>null);
    if(!j || !j.ok) return null;
    const coords = j.coords;
    if(Array.isArray(coords) && coords.length>=2) return coords;
  }catch(e){}
  return null;
}

function renderInfra(kind, items, lines){
  const z = map?.getZoom?.() ?? 0;
  if(kind === "substation"){
    if(z < 15 || z > 16){
      try{ substationGroup.clearLayers(); }catch(e){}
      return;
    }
  }
  const group = (kind === "plant") ? existingGroup : substationGroup;

  if(kind === "substation" && Array.isArray(lines)){
    lines.forEach(ln=>{
      if(!ln || !Array.isArray(ln.coords) || ln.coords.length < 2) return;
      const pl = L.polyline(ln.coords, {weight:3, opacity:0.8, dashArray:'6 6'});
      // ✅ 도로 기반 최단경로(가능한 경우): V-World route → 성공 시 경로로 교체
      (async ()=>{
        if(!Array.isArray(ln.coords) || ln.coords.length!==2) return;
        const a = ln.coords[0], b = ln.coords[1];
        const route = await getRoadRouteCoords(a, b);
        if(route){ pl.setLatLngs(route); pl.setStyle({dashArray:null}); }
      })();
      pl.on("click", ()=>{
        const txt = `한전 선로(확인 필요)<br/>잔여용량: ${(ln.remaining_mw ?? "확인 필요")} MW<br/>가용연도: ${(ln.available_year ?? "확인 필요")}`;
        pl.bindPopup(txt).openPopup();
      });
      pl.addTo(group);
    });
  }

  items.forEach(it=>{
    const lat = it.lat, lng = it.lng;
    if(typeof lat !== "number" || typeof lng !== "number") return;

    if(kind === "plant"){
      const iconHtml = `<div class="w-6 h-3 bg-red-500 border border-red-800 transform -skew-x-12 shadow"></div>`;
      const icon = L.divIcon({ className:"", html: iconHtml, iconSize:[26,14] });
      const mk = L.marker([lat,lng], {icon});
      mk.on("click", ()=>{
        const txt = `기 설치 태양광(확인 필요)<br/>용량: ${(it.capacity_kw ?? "확인 필요")} kW`;
        mk.bindPopup(txt).openPopup();
      });
      mk.addTo(group);
    }else{
      const iconHtml = `<div class="w-7 h-7 flex items-center justify-center bg-yellow-500 rounded-full text-white shadow border border-yellow-700"><span style="font-weight:900">⚡</span></div>`;
      const icon = L.divIcon({ className:"", html: iconHtml, iconSize:[28,28] });
      const mk = L.marker([lat,lng], {icon});
      mk.on("click", ()=>{
        const txt = `${it.name || "변전소"}<br/>잔여용량: ${(it.remaining_mw ?? "확인 필요")} MW<br/>가용연도: ${(it.available_year ?? "확인 필요")}<br/><span style="color:#f59e0b;font-weight:700">확인 필요</span>`;
        mk.bindPopup(txt).openPopup();
      });
      mk.addTo(group);
    }
  });
}

// Called when layer toggles ON or map moves
function refreshInfraIfNeeded(force=false){
  if(!map) return;
  const z = map.getZoom();
  if(z < INFRA_MIN_ZOOM || z > INFRA_MAX_ZOOM){
    try{ map.removeLayer(existingGroup); }catch(e){}
    try{ map.removeLayer(substationGroup); }catch(e){}
    try{ window.virtualInfraLayer && window.virtualInfraLayer.clearLayers(); }catch(e){}
    return;
  }

  if(el("existingPlantToggle")?.checked){
    if(!map.hasLayer(existingGroup)) map.addLayer(existingGroup);
    loadInfra("plant", force);
  }
  if(el("substationToggle")?.checked){
    if(!map.hasLayer(substationGroup)) map.addLayer(substationGroup);
    loadInfra("substation", force);
  }
}


// -----------------------------
// Tab / Sidebar (existing UI callbacks)
// -----------------------------
window.switchTab = function(tab){
  const tabs = ["scan","analysis","legal","history"];
  for(const t of tabs){
    const tb = el(`tab-${t}`);
    const pn = el(`panel-${t}`);
    if(tb) tb.classList.remove("active");
    if(pn) pn.classList.add("hidden");
  }
  const tb = el(`tab-${tab}`);
  const pn = el(`panel-${tab}`);
  if(tb) tb.classList.add("active");
  if(pn) pn.classList.remove("hidden");
};

window.toggleSidebar = function(){
  const sb = el("sidebar");
  const btn = el("sidebar-toggle-btn");
  if(sb) sb.classList.toggle("collapsed");
  if(btn) btn.classList.toggle("collapsed");
};

// -----------------------------
// Feature 2: Mode toggle (F-5)
// -----------------------------
window.toggleTarget = function(){
  if(FEATURE_LEVEL < 2){
    showToast("feat<2: 모드 전환 비활성");
    return;
  }
  const radios = document.getElementsByName("scanTarget");
  for(const r of radios){
    if(r.checked){
      scanTarget = (r.value === "land") ? "land" : "building";
      break;
    }
  }
  clearResults(true);
  showToast(`모드 변경: ${scanTarget === "land" ? "토지" : "지붕"}`);
  logSystem(`mode=${scanTarget}`);
};

// -----------------------------
// Feature 1: Address search (F-4)
// -----------------------------
window.searchAddress = async function(){
  if(FEATURE_LEVEL < 1){
    showToast("feat<1: 주소검색 비활성");
    return;
  }
  const input = el("addrInput");
  const q = (input ? input.value : "").trim();
  if(!q){
    showToast("주소를 입력하세요");
    return;
  }

  const loading = el("loading");
  if(loading) loading.classList.remove("hidden");

  try{
    const url = `https://api.vworld.kr/req/address?service=address&request=getcoord&version=2.0&crs=epsg:4326&address=${encodeURIComponent(q)}&refine=true&simple=false&type=road&key=${VWORLD_TILE_KEY}`;
    const data = await jsonpRequest(url);
    if(data?.response?.status === "OK"){
      const {x,y} = data.response.result.point;
      const lat = parseFloat(y), lng = parseFloat(x);
      map.setView([lat,lng], 18);
      showToast("주소 이동 완료");
      logSystem(`address -> ${lat},${lng}`);
      // auto scan around the location
      if(FEATURE_LEVEL >= 3){
        await new Promise(r=>setTimeout(r, 350));
        const res = await scanBuildings(lat, lng, true);
        if(res?.features?.length){
          analyzeFeature(res.features[0], true);
        }
      }
    } else {
      showToast("주소를 찾을 수 없습니다");
    }
  } catch(e){
    console.error(e);
    showToast("주소검색 오류");
    logSystem(`address error: ${e.message}`);
  } finally {
    if(loading) loading.classList.add("hidden");
  }
};

// -----------------------------
// Multi-select mode (existing toggle)
// -----------------------------
window.toggleMultiSelect = function(){
  const chk = el("multiSelectToggle");
  isMultiSelectMode = !!(chk && chk.checked);
  clearResults(true);
};

// -----------------------------
// Auto scan toggle (F-13/14)
// -----------------------------
window.toggleAutoScan = function(){
  const chk = el("autoScanToggle");
  if(FEATURE_LEVEL < 4){
    if(chk) chk.checked = false;
    autoScanMode = false;
    showToast("feat<4: 자동 스캔 비활성");
    updateAutoScanBox();
    return;
  }
  autoScanMode = !!(chk && chk.checked);
  showToast(autoScanMode ? "자동 스캔 ON" : "자동 스캔 OFF");
  updateAutoScanBox();
};

// -----------------------------
// Core: scan buildings/land from VWorld
// -----------------------------
window.scanBuildings = scanBuildings;
// -----------------------------
// Land price estimate (F-28 readiness) - API-first (backend), fallback "확인 필요"
// -----------------------------

// Try to fetch PNU(19-digit) for a clicked point using VWORLD parcel WMS GetFeatureInfo.
// Returns string like "4118100000101230000" or null.
async function getPnuAtLatLng(lat, lng){
  try{
    if(!window.map || !window.PUBLIC_VWORLD_KEY) return null;

    const size = window.map.getSize();
    const bounds = window.map.getBounds();

    // Project to EPSG:3857
    const crs = window.map.options.crs;
    const sw = crs.project(bounds.getSouthWest());
    const ne = crs.project(bounds.getNorthEast());
    const p = crs.project(L.latLng(lat, lng));

    const bbox = `${sw.x},${sw.y},${ne.x},${ne.y}`;
    const i = Math.round((p.x - sw.x) / (ne.x - sw.x) * size.x);
    const j = Math.round((ne.y - p.y) / (ne.y - sw.y) * size.y);

    const layers = "lp_pa_cbnd_bubun,lp_pa_cbnd_bonbun";
    const styles = "lp_pa_cbnd_bubun,lp_pa_cbnd_bonbun";

    const url = "https://api.vworld.kr/req/wms/1.0.0"
      + `?service=WMS&request=GetFeatureInfo&version=1.1.1`
      + `&layers=${encodeURIComponent(layers)}&query_layers=${encodeURIComponent(layers)}`
      + `&styles=${encodeURIComponent(styles)}&format=image/png&transparent=true`
      + `&feature_count=5&info_format=text/xml`
      + `&srs=EPSG:3857&bbox=${encodeURIComponent(bbox)}`
      + `&width=${size.x}&height=${size.y}&x=${i}&y=${j}`
      + `&key=${encodeURIComponent(window.PUBLIC_VWORLD_KEY)}`;

    const r = await fetch(url, { method: "GET" });
    if(!r.ok) return null;
    const txt = await r.text();

    // PNU is typically a 19-digit number. Grab the first one we find.
    const m = txt.match(/\b\d{19}\b/);
    return m ? m[0] : null;
  }catch(e){
    return null;
  }
}

function updateLandPriceUI(landWon){
  const elLand = document.getElementById("landPrice");
  if(!elLand) return;
  if(typeof landWon === "number" && isFinite(landWon) && landWon > 0){
    elLand.innerText = formatWon(landWon);
    elLand.classList.remove("text-yellow-300");
    elLand.classList.add("text-emerald-300");
  }else{
    elLand.innerText = "확인 필요";
    elLand.classList.remove("text-emerald-300");
    elLand.classList.add("text-yellow-300");
  }
}

window.fetchLandPriceEstimate = async function(address, lat, lng){
  try{
    const backend = getBackendBase();
    if(!backend) return null;

    // ✅ area_m2가 없으면: 패널 수 기반으로라도 면적 추정(널 방지)
    let area_m2 = currentAnalysisData.area_m2;
    if(!area_m2 || area_m2 <= 0){
      const pc = (typeof getTotalPanelCount === "function") ? getTotalPanelCount() : 0;
      // 패널 1장 점유면적(대략) 2.2㎡ + 통로/간격 여유 1.25배
      if(pc && pc > 0) area_m2 = pc * 2.2 * 1.25;
    }

    const payload = {
      address: address||"",
      pnu: currentAnalysisData.pnu || null,
      area_m2: area_m2 || null,
      area_pyeong: (area_m2 ? (area_m2/3.305785) : null),
      lat, lng,
    };
    const r = await fetch(`${backend}/api/land/estimate`, {
      method:"POST",
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload),
      credentials:"include"
    });
    const j = await r.json().catch(()=>null);
    if(!j || !j.ok) return null;
    return j;
  }catch(e){
    console.warn("land price fetch failed", e);
    return null;
  }
};

async function scanBuildings(lat, lng, force=false){
  if(!map) return null;
  if(scanLock && !force) return null;
  scanLock = true;

  let fetchedFeatures = [];
  try{
    if(!isMultiSelectMode){
      selectableGroup.clearLayers();
      panelGroup.clearLayers();
      selectedFeatures.clear();
      currentAnalysisFeature = null;
      resetCalibrationInternal(false);
      // reset UI cards
      const rc = el("resultCard");
      if(rc) rc.classList.add("hidden");
      const lp = el("legalPlaceholder");
      const lc = el("legalContent");
      const sp = el("aiScorePanel");
      if(lp) lp.classList.remove("hidden");
      if(lc) lc.classList.add("hidden");
      if(sp) sp.classList.add("hidden");
    }

    analysisMarkerGroup.clearLayers();
    L.marker([lat,lng]).addTo(analysisMarkerGroup);

    const z = map.getZoom();
    const d = (z >= 17) ? 0.0016 : (z >= 16 ? 0.0028 : 0.0042);
    const box = `${lng - d},${lat - d},${lng + d},${lat + d}`;
    const dataName = (scanTarget === "land") ? "LP_PA_CBND_BUBUN" : "LT_C_SPBD";

    const url = `https://api.vworld.kr/req/data?service=data&request=GetFeature&data=${dataName}&key=${VWORLD_TILE_KEY}&geomFilter=BOX(${box})&size=${(z>=17)?80:(z>=16?120:180)}`;
    const data = await jsonpRequest(url);

    const fc = data?.response?.result?.featureCollection;
    fetchedFeatures = fc?.features || [];
    window.lastScanCandidates = fetchedFeatures;

    L.geoJSON(fetchedFeatures, {
      style: (scanTarget === "land")
        ? { color:"#8d6e63", weight:2, fillColor:"#8d6e63", fillOpacity:0.25 }
        : { color:"#3b82f6", weight:2, fillOpacity:0.20 },
      onEachFeature: (feature, layer) => {
        layer.on("click", (e) => {
          L.DomEvent.stopPropagation(e);
          analyzeFeature(feature, true);
        });
      }
    }).addTo(selectableGroup);

    const found = el("foundCount");
    if(found) found.innerText = `검색된 구역: ${selectableGroup.getLayers().length}개`;

    return { features: fetchedFeatures, count: fetchedFeatures.length };
  } catch(e){
    console.error(e);
    logSystem(`scan error: ${e.message}`);
    return null;
  } finally {
    setTimeout(()=>{ scanLock = false; }, 500);
  }
}

// -----------------------------
// Panel generation (F-6~F-9)
// -----------------------------
function metersToKm(m){ return (m || 0) / 1000; }

function applyCalibrationToFC(fc){
  if(!window.turf || !fc) return fc;
  let out = turf.clone(fc);

  // rotate first around centroid
  if(calibration.rot_deg){
    try { out = turf.transformRotate(out, calibration.rot_deg); } catch(e) {}
  }

  // translate (east-west then north-south)
  if(calibration.dx_m){
    try { out = turf.transformTranslate(out, metersToKm(calibration.dx_m), 90, {units:"kilometers"}); } catch(e) {}
  }
  if(calibration.dy_m){
    try { out = turf.transformTranslate(out, metersToKm(calibration.dy_m), 0, {units:"kilometers"}); } catch(e) {}
  }

  return out;
}

function buildPanelsFCFromGeometry(geo){
  // Safety: fallback grid always visible
  const fallback = () => {
    let bbox = null;
    try { bbox = turf.bbox(turf.feature(geo)); } catch(e) {}
    if(!bbox){
      const c = map.getCenter();
      bbox = [c.lng-0.0004, c.lat-0.0004, c.lng+0.0004, c.lat+0.0004];
    }
    const lat = (bbox[1] + bbox[3]) / 2;
    const mpdLng = 111320 * Math.cos(lat * Math.PI / 180);
    const mpdLat = 111000;

    const modW = 1.13;
    const modH = 2.2;

    const w = modW / mpdLng;
    const h = modH / mpdLat;

    const feats = [];
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        const x = bbox[0] + i*w*1.3;
        const y = bbox[1] + j*h*1.3;
        feats.push(turf.bboxPolygon([x,y,x+w,y+h]));
      }
    }
    return { type:"FeatureCollection", features: feats };
  };

  if(!window.turf) return fallback();

  const isPoly = geo && (geo.type === "Polygon" || geo.type === "MultiPolygon");
  if(!isPoly) return fallback();

  let poly = turf.feature(geo);

  // setback
  let setback = 0;
  const sb = el("setbackDist");
  if(sb) setback = parseFloat(sb.value || "0") || 0;

  if(setback > 0){
    try{
      const shrunk = turf.buffer(poly, -setback, {units:"meters"});
      if(shrunk && shrunk.geometry) poly = shrunk;
      else return fallback();
    } catch(e){
      return fallback();
    }
  }

  // parameters from UI (if present)
  const modW = parseFloat(el("modWidth")?.value || "1.13") || 1.13;
  const modH = parseFloat(el("modHeight")?.value || "2.4") || 2.4;
  const angle = parseFloat(el("installAngle")?.value || "20") || 20;
  const rowSpacing = parseFloat(el("rowSpacing")?.value || "1.2") || 1.2;

  const projectedH = modH * Math.cos(angle * Math.PI / 180);
  const bbox = turf.bbox(poly);
  const centerLat = (bbox[1] + bbox[3]) / 2;
  const mpdLng = 111320 * Math.cos(centerLat * Math.PI / 180);
  const mpdLat = 111000;

  const dLng = (modW + 0.10) / mpdLng;
  const dLat = (projectedH + rowSpacing) / mpdLat;

  const feats = [];
  let guard = 0;
  const MAX = 45000;

  for(let x=bbox[0]; x<bbox[2]; x+=dLng){
    for(let y=bbox[1]; y<bbox[3]; y+=dLat){
      if(guard++ > MAX) break;
      const pt = turf.point([x + dLng/2, y + dLat/2]);
      try{
        if(turf.booleanPointInPolygon(pt, poly)){
          const w = modW / mpdLng;
          const h = projectedH / mpdLat;
          feats.push(turf.bboxPolygon([x, y, x+w, y+h]));
        }
      } catch(e) {}
    }
  }

  if(!feats.length) return fallback();
  return { type:"FeatureCollection", features: feats };
}

function ensureSolarTexture(){
  try{
    if(!window.map) return;
    const pane = map.getPanes()?.overlayPane;
    if(!pane) return;
    const svg = pane.querySelector("svg");
    if(!svg) return;
    if(svg.querySelector("#sp-solar-pattern")) return;

    const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
    const pattern = document.createElementNS("http://www.w3.org/2000/svg","pattern");
    pattern.setAttribute("id","sp-solar-pattern");
    pattern.setAttribute("patternUnits","userSpaceOnUse");
    pattern.setAttribute("width","12");
    pattern.setAttribute("height","12");

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0");
    bg.setAttribute("width","12"); bg.setAttribute("height","12");
    bg.setAttribute("fill","#0b3a8a");
    bg.setAttribute("opacity","0.85");

    const line1 = document.createElementNS("http://www.w3.org/2000/svg","path");
    line1.setAttribute("d","M0 4 H12 M0 8 H12");
    line1.setAttribute("stroke","#93c5fd");
    line1.setAttribute("stroke-width","0.8");
    line1.setAttribute("opacity","0.35");

    const line2 = document.createElementNS("http://www.w3.org/2000/svg","path");
    line2.setAttribute("d","M4 0 V12 M8 0 V12");
    line2.setAttribute("stroke","#93c5fd");
    line2.setAttribute("stroke-width","0.8");
    line2.setAttribute("opacity","0.22");

    pattern.appendChild(bg);
    pattern.appendChild(line1);
    pattern.appendChild(line2);
    defs.appendChild(pattern);
    svg.insertBefore(defs, svg.firstChild);
  }catch(e){}
}

function applySolarTextureToLayer(layer){
  try{
    ensureSolarTexture();
    if(layer && layer._path){
      layer._path.setAttribute("fill", "url(#sp-solar-pattern)");
      layer._path.setAttribute("fill-opacity", "0.80");
      layer._path.setAttribute("stroke", "#0f172a");
      layer._path.setAttribute("stroke-opacity", "0.55");
    }
  }catch(e){}
}

function renderPanelsFC(fc){
  const style = {
    color: "#0f172a",
    weight: 1,
    fillColor: "#0b3a8a",
    fillOpacity: 0.80
  };
  return L.geoJSON(fc, {
    style,
    onEachFeature: (feature, layer)=>{
      // 실사 느낌(텍스처) 적용
      setTimeout(()=>applySolarTextureToLayer(layer), 0);
    }
  });
}

function getFeatureId(feature){
  const props = feature?.properties || {};
  // Prefer PNU if exists
  if(props.pnu) return `pnu:${props.pnu}`;
  // else stable center-based id
  try{
    const c = turf.center(feature).geometry.coordinates;
    return `c:${c[1].toFixed(6)}:${c[0].toFixed(6)}`;
  } catch(e){
    return `t:${_hashSeed(JSON.stringify(props||{}))}`;
  }
}

window.drawPanels = function(geo){
  // public wrapper for debug; not used directly in UI
  const fc = applyCalibrationToFC(buildPanelsFCFromGeometry(geo));
  panelGroup.clearLayers();
  renderPanelsFC(fc).addTo(panelGroup);
  return fc.features.length;
};

function updateResultCardBasics(addr, panelCount){
  const rc = el("resultCard");
  if(rc) rc.classList.remove("hidden");

  if(el("analysisAddress")) el("analysisAddress").innerText = safeText(addr);
  if(el("analysisCount")) el("analysisCount").innerText = `${panelCount} 장`;

  // capacity
  const modPower = parseFloat(el("modPower")?.value || "640") || 640;
  const dcKw = (panelCount * modPower) / 1000;
  const acKw = dcKw / 1.15;
  if(el("analysisCapacity")) el("analysisCapacity").innerText = `${acKw.toFixed(1)} kW (DC: ${dcKw.toFixed(1)})`;

  // kepco (best-effort: backend if available, else deterministic sim)
  try{ if(typeof window.updateKepcoCapacity==="function") window.updateKepcoCapacity(addr, currentAnalysisData?.pnu); }catch(e){
    if(el("kepcoCapacity")) el("kepcoCapacity").innerText = "확인 필요";
  }
}

// Finance summary (kept simple; uses existing UI fields)
window.calculateFinance = function(panelCount, sunHoursOverride){
  try{

  const totalPanels = Math.max(0, parseInt(panelCount || 0, 10));
  const {lat} = getAnalysisLatLng();
  const solar = currentAnalysisData.solar_opt || {};

  // --- Assumptions (editable later) ---
  const degradation = 0.0055; // 0.55%/yr
  const opexInflation = 0.02; // 2%/yr
  const inverterReplaceYear = 13;
  const inverterReplacePct = 0.08; // of EPC

  // Priority: explicit override > solar_opt.sun_hours > heuristic
  const sun = (typeof sunHoursOverride === "number" && sunHoursOverride > 0)
    ? sunHoursOverride
    : ((typeof solar.sun_hours === "number" && solar.sun_hours > 0) ? solar.sun_hours : estimateSunHoursHeuristic(lat));

  // Orientation factor (data-source-free improvement)
  const oriFactor = orientationFactor(lat, solar.azimuth_deg, solar.tilt_deg);

  // --- System sizing ---
  // Use *DC capacity* as the base (module total), consistent with UI "모듈 W" 입력값
  const modPowerW = (parseFloat(el("modPower")?.value || "640") || 640); // W
  const dcKw = (totalPanels * modPowerW) / 1000.0;

  // Keep AC for display only (common DC/AC ratio ~1.15)
  const acKw = dcKw / 1.15;

  // Energy model (Year1)
  // ✅ Fix: avoid double-derating. Standard: DCkW * sunHours * 365 * PR(0.90)
  const PR = 0.90; // 종합 효율(성능비) - 필요시 UI로 노출 가능
  const annualKwhY1 = dcKw * sun * 365 * PR * oriFactor;

  // Prices (placeholders; can be set from UI later)
  const smp = (parseFloat(el("smpPrice")?.value || "120") || 120); // KRW/kWh
  const rec = (parseFloat(el("recPrice")?.value || "60") || 60);   // KRW/kWh-equivalent
  const effectivePrice = smp + rec;

  // CAPEX / OPEX
  const epcWonPerKw = (parseFloat(el("epcPerKw")?.value || "1400000") || 1400000); // won/kW
  const totalCost = dcKw * epcWonPerKw;

  // If PF principal not provided (0), assume LTV 70% of CAPEX for convenience
  let principalInput = (parseFloat(el("pfPrincipal")?.value || "0") || 0);
  const ltvPct = (parseFloat(el("pfLtvPct")?.value || "70") || 70);
  if(principalInput <= 0 && totalCost > 0){
    principalInput = totalCost * (ltvPct/100);
    try{ if(el("pfPrincipal")) el("pfPrincipal").value = Math.round(principalInput); }catch(e){}
  }

  // base OPEX: 2.2% of CAPEX per year (insurance+O&M+misc)
  const baseOpex = totalCost * 0.022;

  // PF
  let principal = (parseFloat(el("pfPrincipal")?.value || "0") || 0);
  const annualRatePct = (parseFloat(el("pfInterestRate")?.value || "6.5") || 6.5);
  const years = (parseInt(el("pfTenorYears")?.value || "10", 10) || 10);
  const dscrTarget = (parseFloat(el("pfDscrTarget")?.value || "1.20") || 1.20);
  const loanRatioPct = (parseFloat(el("pfLoanRatio")?.value || "90") || 90);
  const autoPrincipal = !!(el("pfAutoPrincipal") && el("pfAutoPrincipal").checked);
  const principalCap = totalCost * (loanRatioPct/100);

// ✅ PF 원금 자동은 LTV(%)가 기준, loanRatioPct(%)는 "최대 캡"만
if(totalCost > 0){
  const byLtv = totalCost * (ltvPct/100);
  const capped = Math.min(byLtv, principalCap);

  if(autoPrincipal){
    principal = Math.round(capped);
    try{ el("pfPrincipal").value = principal; }catch(e){}
  }else{
    if(principal <= 0){
      principal = Math.round(byLtv);
      try{ el("pfPrincipal").value = principal; }catch(e){}
    }
  }
}
  // If user typed principal manually, turn off auto (UX)
  try{ if(el("pfPrincipal") && !autoPrincipal && principal<=0 && totalCost>0){} }catch(e){}

  // Local amortization (equal payment) -> yearly schedule
  function buildDebtSchedule(principalWon, annualRate, yearsTerm){
    const P = Math.max(0, principalWon);
    const PF_DAYCOUNT_FACTOR = (365/360); // 시장 표준(은행 실무에서 365/360 사용 케이스 반영)
    const r = Math.max(0, (annualRate/100) * PF_DAYCOUNT_FACTOR / 12);
    const n = Math.max(1, yearsTerm*12);
    let monthly = 0;
    if(P > 0 && yearsTerm > 0){
      if(r <= 0) monthly = P / n;
      else monthly = P * r * Math.pow(1+r, n) / (Math.pow(1+r, n)-1);
    }

    let bal = P;
    const yearly = [];
    let totalInterest = 0;
    let totalPayment = 0;

    for(let y=1; y<=yearsTerm; y++){
      let yInterest=0, yPrincipal=0, yPay=0;
      for(let m=0; m<12; m++){
        if(bal <= 0) break;
        const interest = bal * r;
        let prin = monthly - interest;
        if(prin > bal) prin = bal;
        bal -= prin;
        yInterest += interest;
        yPrincipal += prin;
        yPay += (interest + prin);
      }
      totalInterest += yInterest;
      totalPayment += yPay;
      yearly.push({
        year: y,
        payment: yPay,
        interest: yInterest,
        principal: yPrincipal,
        balance: bal
      });
    }
    return {
      monthly,
      totalInterest,
      totalPayment,
      yearly
    };
  }

  const debt = buildDebtSchedule(principal, annualRatePct, years);


    const yearsHorizon = 25;

  // Cashflow series (year0 includes equity outflow)
  const equity0 = Math.max(0, Math.round(totalCost - principal));
  const cashflows_no_land = [-equity0];
  const cashflows_with_land = [-equity0];

for(let y=1; y<=yearsHorizon; y++){
    // Degradation
    const kwh = annualKwhY1 * Math.pow(1 - degradation, (y-1));
    const revenue = kwh * effectivePrice;

    // OPEX inflation
    const opex = baseOpex * Math.pow(1 + opexInflation, (y-1));

    // Debt (only during PF term)
    const debtService = (y <= years && debt.yearly[y-1]) ? debt.yearly[y-1].payment : 0;

    // Inverter replacement CAPEX (one-off)
    const invReplace = (y === inverterReplaceYear) ? (totalCost * inverterReplacePct) : 0;

    // Cashflow
    const cf = revenue - opex - debtService - invReplace;

    cashflows_no_land.push(Math.round(cf));

    let cfLand = cf;
    if(y === 1 && typeof landPrice === "number" && landPrice > 0){
      // 토지 구매 upfront를 1년차에 반영(리포트에서도 동일 가정)
      cfLand -= landPrice;
    }
    cashflows_with_land.push(Math.round(cfLand));
  }

  
  // DSCR (Debt Service Coverage Ratio) for PF term
  // CADS ~ revenue - opex (before debt service and capex)
  const dscr_years = [];
  const cads_years = [];
  const debt_service_years = [];

  for(let y=1; y<=yearsHorizon; y++){
    const kwh = annualKwhY1 * Math.pow(1 - degradation, (y-1));
    const revenue = kwh * effectivePrice;
    const opex = baseOpex * Math.pow(1 + opexInflation, (y-1));
    const invReplace = (y === inverterReplaceYear) ? (totalCost * inverterReplacePct) : 0;

    const cads = revenue - opex - invReplace; // before debt service
    const ds = (y <= years && debt.yearly[y-1]) ? debt.yearly[y-1].payment : 0;
    const dscr = (ds > 0) ? (cads / ds) : null;

    cads_years.push(Math.round(cads));
    debt_service_years.push(Math.round(ds));
    dscr_years.push((dscr === null || !isFinite(dscr)) ? null : +dscr.toFixed(3));
  }

  function dscrStats(arr){
    const v = arr.filter(x => typeof x === "number" && isFinite(x));
    if(!v.length) return {min:null, avg:null};
    const min = Math.min(...v);
    const avg = v.reduce((a,b)=>a+b,0)/v.length;
    return {min:+min.toFixed(3), avg:+avg.toFixed(3)};
  }
  
  // ---- Max Loan Sizing by Target DSCR (bisection) ----
  function maxLoanByDSCR(target){
    // Solve for principal such that min DSCR >= target
    let lo = 0, hi = Math.max(0, totalCost*0.9); // cap at 90% of CAPEX
    let best = 0;
    for(let it=0; it<30; it++){
      const mid = (lo+hi)/2;
      const debtMid = buildDebtSchedule(mid, annualRatePct, years);
      let minD = Infinity;
      for(let y=1; y<=years; y++){
        const kwh = annualKwhY1 * Math.pow(1 - degradation, (y-1));
        const revenue = kwh * effectivePrice;
        const opex = baseOpex * Math.pow(1 + opexInflation, (y-1));
        const invReplace = (y === inverterReplaceYear) ? (totalCost * inverterReplacePct) : 0;
        const cads = revenue - opex - invReplace;
        const ds = debtMid.yearly[y-1] ? debtMid.yearly[y-1].payment : 0;
        if(ds>0) minD = Math.min(minD, cads/ds);
      }
      if(minD >= target){
        best = mid; lo = mid;
      }else{
        hi = mid;
      }
    }
    return Math.round(best);
  }
const dscrStat = dscrStats(dscr_years);
  const dscr1 = (dscr_years && dscr_years.length>0) ? dscr_years[0] : null;
  const recLoanRaw = maxLoanByDSCR(dscrTarget);
  const recLoan = Math.round(Math.min(principalCap || Infinity, recLoanRaw || 0));

// Payback (Equity payback, simple cumulative, no discount)
// cashflows_no_land = [-equity0, year1..] (Equity CF)
function paybackYearsEquity(cfs, equity0){
  const eq0 = Math.max(0, equity0 || 0);
  if(eq0 <= 0) return 0;
  let cum = -eq0;
  for(let i=1;i<cfs.length;i++){
    cum += (cfs[i] || 0);
    if(cum >= 0) return i; // i=년차
  }
  return null;
}
const payback = paybackYearsEquity(cashflows_no_land, equity0);

  // Update UI
  const annualRevenueWon = annualKwhY1 * effectivePrice;
  if(el("resCapacity")) el("resCapacity").innerText = `${dcKw.toFixed(1)} kW`;
  if(el("resAnnualKwh")) el("resAnnualKwh").innerText = `${Math.round(annualKwhY1).toLocaleString()} kWh`;
  if(el("resAnnualKwh2")) el("resAnnualKwh2").innerText = `${Math.round(annualKwhY1).toLocaleString()} kWh`;
  if(el("resAnnualRev")) el("resAnnualRev").innerText = `${Math.round(annualRevenueWon).toLocaleString()} 원`;
  if(el("resAnnualRevenue")) el("resAnnualRevenue").innerText = `${Math.round(annualRevenueWon).toLocaleString()} 원`;
  if(el("resTotalCost")) el("resTotalCost").innerText = `${Math.round(totalCost).toLocaleString()} 원`;
  if(el("resDebugFinance")) el("resDebugFinance").innerText = `dc=${dcKw.toFixed(1)}kW, sun=${sun.toFixed(2)}h, price=${effectivePrice.toLocaleString()}원/kWh`;
  if(el("resMonthlyDebt")) el("resMonthlyDebt").innerText = `${Math.round(debt.monthly).toLocaleString()} 원`;
  if(el("resPfMonthly")) el("resPfMonthly").innerText = `${Math.round(debt.monthly).toLocaleString()} 원`;
  if(el("resTotalInterest")) el("resTotalInterest").innerText = `${Math.round(debt.totalInterest).toLocaleString()} 원`;
  if(el("resDscr")) el("resDscr").innerText = (dscr1===null||!isFinite(dscr1)) ? "-" : dscr1.toFixed(2);
  if(el("resRecLoan")) el("resRecLoan").innerText = recLoan>0 ? `${recLoan.toLocaleString()} 원` : "-";
  if(el("resPfTotalInterest")) el("resPfTotalInterest").innerText = `${Math.round(debt.totalInterest).toLocaleString()} 원`;
  if(el("resPfPayback")) el("resPfPayback").innerText = (payback===null) ? "> 25년" : `${payback}년`;

  try{ if(typeof updateLandPriceUI==='function') updateLandPriceUI(landPrice); }catch(e){}
  try{ if(typeof updateSolarOptUI==='function') updateSolarOptUI(currentAnalysisData.solar_opt); }catch(e){}

  // Store for report
  currentAnalysisData.finance = {
    totalPanels,
    dcKw,
    acKw,
    annualKwhY1,
    annualRevenueWon: Math.round(annualRevenueWon),
    totalCostWon: Math.round(totalCost),
    monthlyDebtWon: Math.round(debt.monthly),
    totalInterestWon: Math.round(debt.totalInterest),
    paybackYears: payback,
    assumptions: {
      sunHours: sun,
      oriFactor: +oriFactor.toFixed(3),
      azimuthDeg: solar.azimuth_deg ?? null,
      tiltDeg: solar.tilt_deg ?? null,
      degradation,
      opexInflation,
      inverterReplaceYear,
      inverterReplacePct,
      smp,
      rec,
      epcWonPerKw
    },
    roi25y: {
      max_loan_by_dscr_120: maxLoanByDSCR(1.20),
      max_loan_by_dscr_130: maxLoanByDSCR(1.30),
      cashflows_no_land,
      cashflows_with_land,
      land_price_won: landPrice,
      dscr_years,
      cads_years,
      debt_service_years,
      dscr_min: dscrStat.min,
      dscr_avg: dscrStat.avg
    }
  };

  }catch(e){
    console.error('calculateFinance failed', e);
    try{ showToast('재계산 오류: 콘솔을 확인해 주세요'); }catch(_){ }
  }
}// Finance recalculation helper (robust against timing issues)

window.requestFinanceRecalc = function(){
  try{
    const txt = (document.getElementById("resPanels")?.innerText || "").replace(/[^0-9]/g,"");
    const fallback = txt ? parseInt(txt,10) : 0;
    const pc0 = getTotalPanelCount();
    const pc = (pc0 && pc0>0) ? pc0 : fallback;
    if(pc<=0) return;
    window._lastNonZeroPanelCount = pc;
    updateResultCardBasics(currentAnalysisData?.address || "확인 필요", pc);
    window.calculateFinance(pc);
  }catch(e){}
};


// Auto-recalc when panel count changes (lightweight)
;;;

// Analyze feature (F-6)
window.analyzeFeature = analyzeFeature;
function analyzeFeature(feature, focusTab){
  if(FEATURE_LEVEL < 3){
    showToast("feat<3: 패널 생성 비활성");
    return;
  }
  if(!feature?.geometry){
    showToast("지오메트리가 없습니다");
    return;
  }

  if(focusTab) window.switchTab("analysis");

  // Determine address string (F-23 safe)
  const props = feature.properties || {};
  const addr = props.road_nm_ad || props.jibun_addr || props.addr || (props.pnu ? `PNU:${props.pnu}` : "") || "확인 필요";
  currentAnalysisData.pnu = props.pnu || null;

  const featureId = getFeatureId(feature);

  // In multi-select: toggle remove
  if(isMultiSelectMode && selectedFeatures.has(featureId)){
    const stored = selectedFeatures.get(featureId);
    if(stored?.layer) panelGroup.removeLayer(stored.layer);
    selectedFeatures.delete(featureId);
    // recompute totals
    recomputeTotalsAfterSelectionChange();
    return;
  }

  // If not multi-select, reset selection and calibration
  if(!isMultiSelectMode){
    panelGroup.clearLayers();
    selectedFeatures.clear();
    resetCalibrationInternal(false);
  }

  currentAnalysisFeature = feature;

  // Build panels (base -> apply calibration)
  const baseFC = buildPanelsFCFromGeometry(feature.geometry);
  const fc = applyCalibrationToFC(baseFC);

  const layer = renderPanelsFC(fc);
  layer.addTo(panelGroup);

  const count = fc.features.length;

  selectedFeatures.set(featureId, { feature, layer, count, panelsFC: fc, basePanelsFC: baseFC, address: addr });

  // Save lat/lng + area for F-27/28
  try{
    const c = L.geoJSON(feature).getBounds().getCenter();
    currentAnalysisData.lat = c.lat;
    currentAnalysisData.lng = c.lng;
  }catch(e){
    try{
      const c2 = map.getCenter();
      currentAnalysisData.lat = c2.lat;
      currentAnalysisData.lng = c2.lng;
    }catch(e2){}
  }

  try{
    const g = feature?.geometry;
    if(g && g.type === "Polygon"){
      currentAnalysisData.area_m2 = polygonAreaM2(g);
    }else{
      currentAnalysisData.area_m2 = null;
    }
  }catch(e){
    currentAnalysisData.area_m2 = null;
  }

    const pc = getTotalPanelCount();
  updateResultCardBasics(addr, pc);
  setTimeout(()=>window.calculateFinance(pc, (currentAnalysisData.solar_opt?.sun_hours ?? currentAnalysisData.ai_analysis?.sun_hours)),0);
  try{ window.refreshSolarLandEstimates(); }catch(e){}

// ✅ 한전 용량(카드용) 조회: PNU 기반
(async ()=>{
  try{
    if(!BACKEND_URL) return;
    const pnu = currentAnalysisData.pnu || "";
    if(!pnu) return;
    const r = await fetch(`${BACKEND_URL}/api/infra/kepco?pnu=${encodeURIComponent(pnu)}`, {credentials:"include"});
    const j = await r.json().catch(()=>null);
    const kcEl = el("kepcoCapacity");
      if(!kcEl) return;
      const cap = (j && j.ok) ? j.kepco_capacity : null;
      if(!cap || String(cap).includes("조회 불가")){
        kcEl.innerText = "조회 불가 (한전 문의 요망)";
        kcEl.classList.add("text-red-400");
      }else{
        kcEl.innerText = String(cap);
        kcEl.classList.remove("text-red-400");
      }
  }catch(e){}
})();


  // ✅ 사용자 미세보정 핸들 표시
  try{ ensurePanelDragHandle(feature); }catch(e){}

  // Save analysis data basics
  currentAnalysisData.address = addr;
  currentAnalysisData.mode = (scanTarget === "land") ? "land" : "roof";
  currentAnalysisData.updated_at = new Date().toISOString();

  // AI analysis (F-15/16)
  if(FEATURE_LEVEL >= 5){
    try{
      const center = turf.center(feature).geometry.coordinates;
      fetchAIData(center[1], center[0], addr);
    }catch(e){
      fetchAIData(null, null, addr);
    }
  }
}

function getTotalPanelCount(){
  let sum = 0;
  for(const v of selectedFeatures.values()) sum += (v.count || 0);
  return sum;
}

function recomputeTotalsAfterSelectionChange(){
  const total = getTotalPanelCount();
  if(el("analysisCount")) el("analysisCount").innerText = `${total} 장`;
  window.calculateFinance(total, (currentAnalysisData.solar_opt?.sun_hours ?? currentAnalysisData.ai_analysis?.sun_hours));
  showToast(`선택: ${selectedFeatures.size}개 / 패널 ${total}장`);
}

// Recalculate panels after parameter changes (F-9)
window.reCalculate = function(){
  if(FEATURE_LEVEL < 3) return;

  if(!selectedFeatures.size){
    showToast("선택된 구역이 없습니다");
    return;
  }

  // For simplicity: recompute all selected features with current parameters.
  panelGroup.clearLayers();

  const updated = new Map();
  for(const [id, v] of selectedFeatures.entries()){
    const baseFC = buildPanelsFCFromGeometry(v.feature.geometry);
    // Only apply calibration to the currently focused feature
    const fc = (currentAnalysisFeature && id === getFeatureId(currentAnalysisFeature))
      ? applyCalibrationToFC(baseFC)
      : baseFC;

    const layer = renderPanelsFC(fc);
    layer.addTo(panelGroup);

    updated.set(id, { ...v, layer, count: fc.features.length, panelsFC: fc, basePanelsFC: baseFC });
  }
  selectedFeatures = updated;

  const total = getTotalPanelCount();
  if(el("analysisCount")) el("analysisCount").innerText = `${total} 장`;
  window.calculateFinance(total, (currentAnalysisData.solar_opt?.sun_hours ?? currentAnalysisData.ai_analysis?.sun_hours));
  showToast("재계산 완료");
};

// -----------------------------
// D-pad calibration (F-10)
// -----------------------------
function resetCalibrationInternal(recalc=true){
  calibration = { dx_m: 0, dy_m: 0, rot_deg: 0 };
  if(recalc) window.reCalculate();
}

window.resetCalibration = function(){
  resetCalibrationInternal(true);
};

window.applyCalibration = function(dx, dy, drot=0){
  if(FEATURE_LEVEL < 3) return;
  calibration.dx_m += (dx || 0);
  calibration.dy_m += (dy || 0);
  calibration.rot_deg += (drot || 0);
  window.reCalculate();
};

window.dpadHoldStart = function(dir){
  if(FEATURE_LEVEL < 3) return;
  window.dpadHoldStop();

  const step = 0.2; // meters
  const tick = () => {
    if(dir === "up") window.applyCalibration(0,  step);
    if(dir === "down") window.applyCalibration(0, -step);
    if(dir === "left") window.applyCalibration(-step, 0);
    if(dir === "right") window.applyCalibration(step, 0);
    if(dir === "rotL") window.applyCalibration(0, 0, -2);
    if(dir === "rotR") window.applyCalibration(0, 0,  2);
  };

  tick();
  dpadHoldTimer = setInterval(tick, 120);
};

window.dpadHoldStop = function(){
  if(dpadHoldTimer){
    clearInterval(dpadHoldTimer);
    dpadHoldTimer = null;
  }
};

// -----------------------------
// F-11~F-14: Scan mission + auto scan box
// -----------------------------
const REGION_PLANS = {
  "ansan_ind":     { name:"안산 반월/시화", steps: 120 },
  "incheon_ind":   { name:"인천 남동공단", steps: 120 },
  "hwaseong_ind":  { name:"화성 일반산단", steps: 140 },
  "pyeongtaek_ind":{ name:"평택 포승공단", steps: 140 },
  "cheonan_ind":   { name:"천안 일반산단", steps: 140 },
  "osan_ind":      { name:"오창 과학산단", steps: 140 },
  "daejeon_ind":   { name:"대전 대덕", steps: 140 },
  "gumi_ind":      { name:"구미 국가산단", steps: 160 },
  "changwon_ind":  { name:"창원 국가산단", steps: 160 },
  "ulsan_ind":     { name:"울산 미포/온산", steps: 160 },
  "daegu_ind":     { name:"대구 성서", steps: 160 },
  "pohang_ind":    { name:"포항 철강", steps: 160 },
  "seoul":         { name:"서울", steps: 260 },
  "gyeonggi":      { name:"경기", steps: 420 },
  "jeonnam":       { name:"전남", steps: 360 },
  "jeonbuk":       { name:"전북", steps: 320 },
  "gyeongnam":     { name:"경남", steps: 360 },
  "jeju":          { name:"제주", steps: 240 },
};

let selectedRegionKey = "";

window.setRegion = function(){
  const sel = el("regionSelect");
  selectedRegionKey = (sel && sel.value) ? sel.value : "";
  window.updateEstimatedTime();
};

window.updateEstimatedTime = function(){
  const delaySel = el("scanDelay");
  missionDelayMs = parseInt(delaySel?.value || "6000", 10);

  const plan = REGION_PLANS[selectedRegionKey];
  missionTotalSteps = plan ? plan.steps : 20;

  // F-11: 예상 총 소요시간 = steps * delay (추후 region bbox 기반 정밀화 가능)
  missionTotalMs = missionTotalSteps * missionDelayMs;
  missionRemainingMs = missionTotalMs;

  if(el("timerRemaining")) el("timerRemaining").innerText = fmtHHMMSS(missionRemainingMs);
  if(el("timerTotal")) el("timerTotal").innerText = `총 ${fmtHHMMSS(missionTotalMs)}`;
  if(el("progressCount")) el("progressCount").innerText = `0 / ${missionTotalSteps}`;
  if(el("totalProgressBar")) el("totalProgressBar").style.width = "0%";
};

function stopMissionTimer(){
  if(missionTimerInterval){
    clearInterval(missionTimerInterval);
    missionTimerInterval = null;
  }
}

function startMissionTimer(){
  stopMissionTimer();
  missionLastTick = Date.now();

  missionTimerInterval = setInterval(()=>{
    if(!missionRunning){ stopMissionTimer(); return; }

    const now = Date.now();

    // F-12: 일시정지 시 시간 감소 X (resume 시 기준 재설정)
    if(missionPaused){
      missionLastTick = now;
      return;
    }

    const dt = Math.max(0, now - missionLastTick);
    missionLastTick = now;

    missionRemainingMs = Math.max(0, missionRemainingMs - dt);

    if(el("timerRemaining")) el("timerRemaining").innerText = fmtHHMMSS(missionRemainingMs);
    if(el("timerTotal")) el("timerTotal").innerText = `총 ${fmtHHMMSS(missionTotalMs)}`;

    if(missionTotalMs > 0 && el("totalProgressBar")){
      const done = Math.min(1, (missionTotalMs - missionRemainingMs) / missionTotalMs);
      // Progress bar는 "전수 스캔 진행률"로 유지하되, step 기반 업데이트가 우선
      // 여기서는 최소한 남은시간 기반으로도 자연스럽게 움직이도록 보정
      const w = (done * 100);
      const cur = parseFloat(el("totalProgressBar").style.width || "0");
      if(!isNaN(cur) && w > cur){
        el("totalProgressBar").style.width = `${w}%`;
      }
    }

    if(missionRemainingMs <= 0) stopMissionTimer();
  }, 250);
}

window.startMission = async function(){
  if(FEATURE_LEVEL < 4){
    showToast("feat<4: 전수 스캔 비활성");
    return;
  }
  if(!map) return;

  // Toggle pause/resume
  if(missionRunning){
    missionPaused = !missionPaused;
    const btn = el("startBtn");
    if(btn) btn.innerText = missionPaused ? "▶ 재개" : "⏸ 일시정지";
    showToast(missionPaused ? "일시정지" : "재개");
    return;
  }

  // Start mission
  missionRunning = true;
  missionPaused = false;
  missionStop = false;
  missionDoneSteps = 0;

  window.updateEstimatedTime();
  // Timer uses missionRemainingMs (pause-aware)
  startMissionTimer();

  const btn = el("startBtn");
  if(btn) btn.innerText = "⏸ 일시정지";

  const autoFollow = !!(el("autoFollow")?.checked);
  const bounds = map.getBounds();

  for(let i=0;i<missionTotalSteps;i++){
    if(missionStop) break;
    while(missionPaused){
      await new Promise(r=>setTimeout(r, 200));
      if(missionStop) break;
    }
    if(missionStop) break;

    const t = (missionTotalSteps <= 1) ? 0 : (i / (missionTotalSteps-1));
    const lat = bounds.getSouth() + (bounds.getNorth()-bounds.getSouth()) * t;
    const lng = bounds.getWest()  + (bounds.getEast()-bounds.getWest()) * (((i*7) % missionTotalSteps) / missionTotalSteps);

    if(autoFollow) map.panTo([lat,lng], {animate:false});

    await scanBuildings(lat, lng, true);

    missionDoneSteps = i+1;

    if(el("progressCount")) el("progressCount").innerText = `${missionDoneSteps} / ${missionTotalSteps}`;
    if(el("totalProgressBar")) el("totalProgressBar").style.width = `${(missionDoneSteps/missionTotalSteps)*100}%`;

    // 남은시간 보정: step 기반 예상값보다 크게 남아있으면 줄여줌(스캔이 빠를 때)
    const expectedLeft = Math.max(0, (missionTotalSteps - missionDoneSteps) * missionDelayMs);
    if(missionRemainingMs > expectedLeft) missionRemainingMs = expectedLeft;

    await new Promise(r=>setTimeout(r, missionDelayMs));
  }

  missionRunning = false;
  missionPaused = false;
  stopMissionTimer();

  if(btn) btn.innerText = "▶ 스캔 시작";
  showToast(missionStop ? "스캔 취소" : "스캔 완료");
};

window.cancelMission = function(keepResults){
  missionStop = true;
  missionPaused = false;
  missionRunning = false;
  stopMissionTimer();

  const btn = el("startBtn");
  if(btn) btn.innerText = "▶ 스캔 시작";

  if(!keepResults){
    clearResults(true);
  }
  window.updateEstimatedTime();
};

window.downloadScanResults = function(fmt){
  // Export current selectable polygons
  try{
    const geojson = selectableGroup.toGeoJSON();
    const blob = new Blob([JSON.stringify(geojson, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `scan_results.${fmt === "geojson" ? "geojson" : "json"}`;
    a.click();
    URL.revokeObjectURL(url);
  }catch(e){
    showToast("다운로드 실패");
  }
};

function updateAutoScanBox(){
  if(!map){
    if(autoScanBox){ try{ autoScanBox.remove(); }catch(e){} autoScanBox=null; }
    return;
  }
  if(!(FEATURE_LEVEL >= 4 && autoScanMode)){
    if(autoScanBox){ try{ autoScanBox.remove(); }catch(e){} autoScanBox=null; }
    return;
  }

  // F-14: 지도 중심 기준 자동 스캔 범위(노란 점선 박스)
  // - 줌 레벨에 무관하게 "대략 일정 거리(m)"로 유지 (보수적)
  const c = map.getCenter();
  const halfMeters = 250; // 한 변 약 500m (추후 설정값으로 노출 가능)

  const dLat = halfMeters / 111320; // meters -> deg
  const dLng = halfMeters / (111320 * Math.max(0.2, Math.cos(c.lat * Math.PI / 180)));

  const bounds = [[c.lat - dLat, c.lng - dLng], [c.lat + dLat, c.lng + dLng]];

  if(!autoScanBox){
    autoScanBox = L.rectangle(bounds, {color:"#fbbf24", weight:2, fillOpacity:0, dashArray:"5,5"}).addTo(map);
  }else{
    autoScanBox.setBounds(bounds);
  }
}

// -----------------------------
// AI analysis (F-15/16)
// -----------------------------
async function postJson(url, body){
  const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body||{}), credentials:"include"});
  // Let caller handle non-OK for fallback
  const text = await res.text();
  let data = null;
  try { data = JSON.parse(text); } catch(e) { data = { raw: text }; }
  return { ok: res.ok, status: res.status, data };
}

const __CHECK_LINKS = {
  "조례": "https://www.elis.go.kr/",
  "용도지역": "https://www.eum.go.kr/web/am/amMain.jsp",
  "상위법": "https://law.go.kr/main.html",
  "생태": "https://aid.mcee.go.kr/",
  "문화재": "https://www.nie-ecobank.kr/cmmn/Index.do",
  "경사": "https://webgis.neins.go.kr/map.do",
  "계통": "https://online.kepco.co.kr/",
  "변전소": "https://online.kepco.co.kr/",
  "선로": "https://online.kepco.co.kr/",
  "한전": "https://online.kepco.co.kr/",
};
function __deriveCheckLink(title){
  const t = String(title||"");
  for(const k in __CHECK_LINKS){
    if(t.includes(k)) return __CHECK_LINKS[k];
  }
  // 도시/군 조례도 조례 시스템으로
  if(t.includes("도시") || t.includes("군") || t.includes("지자체")) return "https://www.elis.go.kr/";
  return "";
}

function renderAIResult(payload){
  // Expected: checks[], attractiveness_score or ai_score
  const container = el("aiAnalysisResult");
  if(container){
    const checks = Array.isArray(payload.checks) ? payload.checks : [];
    const summary = payload.ai_summary || payload.summary || "";
    const sumPanel = el("aiSummaryPanel");
    const sumText = el("aiSummaryText");
    if(sumPanel && sumText){
      if(summary){ sumPanel.classList.remove("hidden"); sumText.textContent = String(summary); }
      else { sumPanel.classList.add("hidden"); sumText.textContent = ""; }
    }
    container.innerHTML = checks.map(item => {
      const title = safeText(item.title || item.category, "");
      const result = safeText(item.message || item.result || item.status || "", "확인 필요");
      const link = (item.link || item.url || __deriveCheckLink(title) || "");
      const needs = item.needs_confirm || item.confirm_needed || (String(result).includes("확인") && String(result).includes("필요"));
      return `
        <div class="bg-slate-700/50 p-2 rounded border border-slate-600 flex justify-between items-center text-[10px]">
          <div class="flex items-center gap-2">
            <div class="text-cyan-400">✓</div>
            <div>
              <div class="text-slate-300 font-bold">${title}</div>
              <div class="${needs ? "text-yellow-300" : "text-white"} truncate w-60">${result}</div>
            </div>
          </div>
          ${link ? `<a href="${link}" target="_blank" class="bg-slate-600 px-2 py-1 rounded hover:bg-slate-500">링크</a>` : ""}
        </div>
      `;
    }).join("") || `<div class="text-slate-300 text-xs">AI 결과가 없습니다.</div>`;
  }

  // Score
  const scorePanel = el("aiScorePanel");
  const scoreValue = el("scoreValue");
  const scoreBar = el("scoreBar");
  const confidenceValue = el("confidenceValue");

  // Score priority: payload.attractiveness_score or payload.ai_score.score
  let score = null;
  let confidence = null;
  if(typeof payload.attractiveness_score === "number") score = payload.attractiveness_score;
  else if(payload.ai_score && typeof payload.ai_score.score === "number") score = payload.ai_score.score;

  if(payload.ai_score && typeof payload.ai_score.confidence === "number") confidence = payload.ai_score.confidence;
  if(typeof payload.confidence === "number") confidence = payload.confidence;

  if(scorePanel && scoreValue && scoreBar){
    if(score === null) {
      scorePanel.classList.add("hidden");
    } else {
      scorePanel.classList.remove("hidden");
      const s = Math.max(0, Math.min(100, Math.round(score)));
      scoreValue.innerText = `${s}점`;
      scoreBar.style.width = `${s}%`;
      if(confidenceValue) confidenceValue.innerText = (confidence !== null) ? `신뢰도: ${confidence}%` : "";
    }
  }

  // Kepco capacity field if present
  if(el("kepcoCapacity")){
    const kc = payload.kepco_capacity || payload.kepco || null;
    if(kc) el("kepcoCapacity").innerText = safeText(kc);
  }

  // sun hours if present
  if(typeof payload.sun_hours === "number"){
    currentAnalysisData.ai_analysis = currentAnalysisData.ai_analysis || {};
    currentAnalysisData.ai_analysis.sun_hours = payload.sun_hours;
  }
}

window.fetchAIData = async function(lat, lng, addr){
  if(FEATURE_LEVEL < 5) return;
  if(!BACKEND_URL){
    logSystem("AI skipped: BACKEND_URL not set (use ?backend=...)");
    return;
  }

  const placeholder = el("legalPlaceholder");
  const loading = el("legalLoading");
  const content = el("legalContent");

  if(placeholder) placeholder.classList.add("hidden");
  if(content) content.classList.add("hidden");
  if(loading) loading.classList.remove("hidden");
  const ll = getAnalysisLatLng();
  const lat0 = (typeof lat === "number" && isFinite(lat)) ? lat : ll.lat;
  const lng0 = (typeof lng === "number" && isFinite(lng)) ? lng : ll.lng;

  const payload = {
    address: addr,
    mode: (scanTarget === "land") ? "land" : "roof",
    lat: lat0, lng: lng0,
    panel_count: getTotalPanelCount(),
    setback_m: parseFloat(el("setbackDist")?.value || "0") || 0,
  };

  try{
    // Spec says: POST /api/analyze/basic (Fast)
    let r = await postJson(`${BACKEND_URL}/api/analyze/basic`, payload);
    if(!r.ok){
      // fallback to existing path used previously in drafts
      r = await postJson(`${BACKEND_URL}/api/ai/analyze`, payload);
    }
    if(!r.ok){
      throw new Error(`AI HTTP ${r.status}`);
    }

    currentAnalysisData.ai_analysis = r.data;

    if(loading) loading.classList.add("hidden");
    if(content) content.classList.remove("hidden");

    renderAIResult(r.data);

    try { if (typeof fetchEightChecks === "function") { fetchEightChecks(); } } catch (e) { console.error("Eight-checks render failed", e); }

    // F-27/28 refresh (API-first)
    try{ window.refreshSolarLandEstimates(); }catch(e){}

    // Recalc finance with sun hours if present
    if(typeof r.data.sun_hours === "number"){
      window.calculateFinance(getTotalPanelCount(), r.data.sun_hours);
    }
  } catch(e){
    if(loading) loading.classList.add("hidden");
    if(placeholder) {
      placeholder.classList.remove("hidden");
      placeholder.innerHTML = `<div class="text-center py-10 text-slate-400 text-xs">기본 분석 실패<br><span class="text-[10px]">${safeText(e.message,"")}</span></div>`;
    }
    logSystem(`AI error: ${e.message}`);
  }
};

// -----------------------------
// Report / History (minimal, keeps UI)
// -----------------------------
window.openFullReport = function(){
  const form = el("reportForm");
  if(!form){
    showToast("reportForm not found");
    return;
  }
  if(!BACKEND_URL){
    showToast("backend 미설정");
    return;
  }
  // Fill hidden fields if exist
  if(el("form_address")) el("form_address").value = safeText(currentAnalysisData.address, "");
  if(el("form_capacity")) el("form_capacity").value = safeText(el("analysisCapacity")?.innerText, "");
  if(el("form_kepco")) el("form_kepco").value = safeText(el("kepcoCapacity")?.innerText, "확인 필요");
  if(el("form_date")) el("form_date").value = new Date().toLocaleString();
  if(el("form_mode")) el("form_mode").value = (scanTarget === "land") ? "land" : "roof";
  if(el("form_lat")) el("form_lat").value = String(currentAnalysisData?.lat ?? currentAnalysisData?.center?.lat ?? "");
  if(el("form_lng")) el("form_lng").value = String(currentAnalysisData?.lng ?? currentAnalysisData?.center?.lng ?? "");
  if(el("form_pnu")) el("form_pnu").value = String(currentAnalysisData?.pnu ?? "");
  if(el("form_finance")) el("form_finance").value = JSON.stringify(currentAnalysisData.finance || {});
  if(el("form_ai")) el("form_ai").value = JSON.stringify(currentAnalysisData.ai_analysis || {});
  if(el("form_solar")) el("form_solar").value = JSON.stringify(currentAnalysisData.solar_opt || {});
  if(el("form_land")) el("form_land").value = JSON.stringify(currentAnalysisData.land_estimate || {});
  if(el("form_score")) el("form_score").value = JSON.stringify(currentAnalysisData.ai_analysis?.attractiveness_score || 0);
  if(el("form_price")) el("form_price").value = ""; // placeholder

  form.action = `${BACKEND_URL}/report`;
  form.submit();
};

function historyKey(){ return "sp_history_v1"; }

function loadHistory(){
  try{
    const raw = localStorage.getItem(historyKey());
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function saveHistory(items){
  try{ localStorage.setItem(historyKey(), JSON.stringify(items)); }catch(e){}
}

function renderHistory(){
  const list = el("historyList");
  if (!list) return;

  const items = loadHistory();
  if (!items.length) {
    list.innerHTML = `<div class="text-xs text-slate-400">기록이 없습니다.</div>`;
    return;
  }

  // 매력도 점수 계산 (AI 분석 기반)
  const scored = items.map((it, idx) => {
    const ai = it.ai || {};
    let score = null;

    if (typeof ai.attractiveness_score === "number") {
      score = ai.attractiveness_score;
    } else if (ai.ai_score && typeof ai.ai_score.score === "number") {
      score = ai.ai_score.score;
    }

    return { it, idx, score };
  });

  // 점수 기준 내림차순 정렬, 점수 없는 항목은 맨 뒤
  scored.sort((a, b) => {
    const sa = (typeof a.score === "number") ? a.score : -1;
    const sb = (typeof b.score === "number") ? b.score : -1;
    return sb - sa;
  });

  // 상위 10개만 사용
  const top = scored.slice(0, 10);

  list.innerHTML = top.map(({ it, score, idx }, rank)=>`
    <div class="bg-white border border-slate-200 rounded p-2 text-xs shadow-sm flex justify-between items-center gap-2">
      <div>
        <div class="flex items-center gap-1">
          <span class="inline-flex items-center justify-center w-5 h-5 rounded-full bg-slate-800 text-white font-bold">${rank+1}</span>
          <span class="font-bold text-slate-700 truncate max-w-[180px]" title="${escapeHtml(it.address || "확인 필요")}">
            ${escapeHtml(it.address || "확인 필요")}
          </span>
        </div>
        <div class="text-[10px] text-slate-500">
          ${escapeHtml(it.time || "")}
        </div>
        <div class="text-[10px] text-slate-600">
          패널 ${it.panelCount || 0}장 · 모드 ${escapeHtml(it.mode || "")} · 점수 ${ (typeof score === "number") ? Math.round(score) + "점" : "-" }
        </div>
      </div>
      <div class="flex items-center gap-1">
        <button type="button"
                class="inline-flex items-center justify-center w-6 h-6 rounded-full border border-slate-300 text-[10px] text-slate-600 bg-slate-50"
                title="상세 리포트 (추후 구현)">
          <i class="ph ph-magnifying-glass"></i>
        </button>
        <button type="button"
                class="inline-flex items-center justify-center w-6 h-6 rounded-full border border-red-200 text-[10px] text-red-600 bg-red-50 hover:bg-red-100"
                title="이 기록 삭제"
                onclick="window.deleteHistoryEntry(${idx})">
          <i class="ph ph-trash"></i>
        </button>
      </div>
    </div>
  `).join("");
}

window.saveResult = function(){
  const items = loadHistory();
  const entry = {
    time: new Date().toLocaleString(),
    address: safeText(currentAnalysisData.address, "확인 필요"),
    mode: currentAnalysisData.mode || (scanTarget==="land"?"land":"roof"),
    panelCount: getTotalPanelCount(),
    finance: currentAnalysisData.finance || {},
    ai: currentAnalysisData.ai_analysis || {}
  };
  items.unshift(entry);
  saveHistory(items.slice(0, 100));
  showToast("저장 완료");
  renderHistory();
};

window.clearHistory = function(){
  saveHistory([]);
  showToast("기록 삭제");
  renderHistory();
};

window.downloadCSV = function(){
  const items = loadHistory();
  if(!items.length){
    showToast("다운로드할 기록이 없습니다");
    return;
  }
  const rows = [["time","address","mode","panelCount","acCapacityKw","annualRevenueWon","totalCostWon","score"]];
  for(const it of items){
    const fin = it.finance || {};
    const score = (it.ai && (it.ai.attractiveness_score ?? it.ai.ai_score?.score)) ?? "";
    rows.push([
      it.time || "",
      (it.address || "").replaceAll("\n"," ").replaceAll(","," "),
      it.mode || "",
      it.panelCount || 0,
      fin.acCapacityKw ?? "",
      fin.annualRevenueWon ?? "",
      fin.totalCostWon ?? "",
      score
    ]);
  }
  const csv = rows.map(r => r.map(v => `"${String(v ?? "").replaceAll('"','""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "solar_pathfinder_history.csv";
  a.click();
  URL.revokeObjectURL(url);
};

// -----------------------------
// Clear / reset helper
// -----------------------------
function clearResults(clearToasts){
  selectableGroup.clearLayers();
  panelGroup.clearLayers();
  analysisMarkerGroup.clearLayers();
  selectedFeatures.clear();
  currentAnalysisFeature = null;
  currentAnalysisData = {};
  resetCalibrationInternal(false);

  const found = el("foundCount");
  if(found) found.innerText = "검색된 구역: 0개";

  if(clearToasts) showToast("초기화");
}

// -----------------------------
// Boot
// -----------------------------

// ---------- Public access key binding ----------
async function ensurePublicAuth() {
  try {
    const r = await fetch(`${backendBase}/api/auth/status`, { credentials: 'include' });
    const j = await r.json();
    if (!j || !j.ok) return;
    if (!j.enabled) return; // auth disabled
    if (j.authed) return;   // already authed

    const modal = document.getElementById('publicAuthModal');
    const input = document.getElementById('publicKeyInput');
    const err = document.getElementById('publicKeyErr');
    const submit = document.getElementById('publicKeySubmit');
    const reset = document.getElementById('publicKeyReset');

    modal.classList.remove('hidden');
    modal.classList.add('flex');

    // prevent repeat binding attempt in same browser (simple UX safeguard)
    const boundFlag = localStorage.getItem('sp_key_bound') === '1';
    if (boundFlag) {
      err.textContent = "이 브라우저에서는 이미 인증키를 등록했습니다. (쿠키가 삭제된 경우 서버에서 다시 인증이 필요할 수 있어요)";
      err.classList.remove('hidden');
    }

    await new Promise((resolve) => {
      submit.onclick = async () => {
        err.classList.add('hidden');
        const key = (input.value || '').trim();
        if (!key) {
          err.textContent = "인증키를 입력하세요.";
          err.classList.remove('hidden');
          return;
        }
        submit.disabled = true;
        submit.textContent = "확인 중...";
        try {
          const rr = await fetch(`${backendBase}/api/auth/bind`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ key })
          });
          const jj = await rr.json().catch(() => ({}));
          if (!rr.ok || !jj.ok) {
            err.textContent = (jj && jj.msg) ? jj.msg : "인증에 실패했습니다.";
            err.classList.remove('hidden');
            submit.disabled = false;
            submit.textContent = "확인";
            return;
          }
          localStorage.setItem('sp_key_bound', '1');
          modal.classList.add('hidden');
          modal.classList.remove('flex');
          resolve();
        } catch (e) {
          err.textContent = "네트워크 오류가 발생했습니다.";
          err.classList.remove('hidden');
          submit.disabled = false;
          submit.textContent = "확인";
        }
      };

      reset.onclick = () => {
        localStorage.removeItem('sp_key_bound');
        location.reload();
      };
    });
  } catch (e) {
    // ignore
  }
}

window.onload = async function(){
    await ensurePublicAuth();

  // stop dpad when focus lost
  window.addEventListener("blur", window.dpadHoldStop);
  window.initMap();
  window.updateEstimatedTime();
  renderHistory();

  // Safety: avoid undefined in UI
  if(el("analysisAddress")) el("analysisAddress").innerText = "확인 필요";
  if(el("kepcoCapacity")) el("kepcoCapacity").innerText = "확인 필요";

  // If checkboxes exist, initialize
  autoScanMode = !!(el("autoScanToggle")?.checked);
  isMultiSelectMode = !!(el("multiSelectToggle")?.checked);
};
</script>
<script>
// Accessibility patch: label Leaflet interactive markers (for audit tools)
window._a11yLeafletPatch = true;
(function(){
  const apply = () => {
    document.querySelectorAll('.leaflet-marker-icon.leaflet-interactive[role="button"]').forEach((el)=>{
      if(!el.getAttribute('aria-label')) el.setAttribute('aria-label','지도 마커');
      if(!el.getAttribute('title')) el.setAttribute('title','지도 마커');
    });
  };
  setInterval(apply, 1500);
})();
</script>

<script>
window._pfAutoWire = true;
(function(){
  function wire(){
    const p = document.getElementById('pfPrincipal');
    const a = document.getElementById('pfAutoPrincipal');
    if(!p || !a) return;
    if(p._wired) return;
    p._wired = true;
    p.addEventListener('input', ()=>{
      const v = parseFloat(p.value||"0")||0;
      if(v>0){ a.checked = false; }
    });
  }
  setInterval(wire, 1200);
})();


/* ============================================================
   UX 개선: (A) 인프라(변전소/선로 가상) 레이어 흔들림 완화
          (B) 빈곳 클릭 시 주변 설치가능지역 빠른 선택
   ============================================================ */

// ---------- (A) Infra jitter fix: cache + grid snapping ----------
window.__infraCache = window.__infraCache || { key: null, layers: null };

function _latLngToTile(lat, lng, z){
  const latRad = lat * Math.PI / 180;
  const n = Math.pow(2, z);
  const x = Math.floor((lng + 180) / 360 * n);
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return {x, y, z};
}

// ✅ 줌/이동에도 '같은 지역이면 같은 seed' (고정 타일 z=12 기준)
function _infraKeyFromView(kind="substation") {
  const c = window.map?.getCenter?.();
  if (!c) return null;
  const zFixed = 12;
  const t = _latLngToTile(c.lat, c.lng, zFixed);
  return `${kind}:t${t.z}:${t.x}:${t.y}`;
}

// If your code already draws virtual infra each move, call this instead.
async 
function refreshInfraLayerStable(force=false) {
  try{
    if(!window.map) return;

    const z = window.map.getZoom();
    const MINZ = 15, MAXZ = 16; // show only in this zoom range
    const showable = (z >= MINZ && z <= MAXZ);

    // Respect UI toggle
    const chk = el("substationToggle");
    const enabled = chk ? chk.checked : true;

    if(!enabled || !showable){
      try{ window.virtualInfraLayer && window.virtualInfraLayer.clearLayers(); }catch(e){}
      return;
    }

    if(!window.virtualInfraLayer){
      window.virtualInfraLayer = L.layerGroup();
      try{ window.virtualInfraLayer.addTo(window.map); }catch(e){}
    }else{
      if(!window.map.hasLayer(window.virtualInfraLayer)){
        try{ window.virtualInfraLayer.addTo(window.map); }catch(e){}
      }
    }

    // Grid-based deterministic caching (no jitter on pan)
    const bounds = window.map.getBounds();
    const cell = 0.01; // ~1km grid (tune)
    const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
    const minLng = bounds.getWest(),  maxLng = bounds.getEast();

    const iMin = Math.floor(minLat / cell);
    const iMax = Math.floor(maxLat / cell);
    const jMin = Math.floor(minLng / cell);
    const jMax = Math.floor(maxLng / cell);

    window.__virtualInfraCache = window.__virtualInfraCache || { markers: new Map() };

    // Rebuild visible set each refresh (markers are cached, only added/removed)
    window.virtualInfraLayer.clearLayers();

    const capText = (window.currentAnalysisData?.ai_analysis?.kepco_capacity) || null;
    for(let i=iMin; i<=iMax; i++){
      for(let j=jMin; j<=jMax; j++){
        const key = `${i}_${j}`;
        let m = window.__virtualInfraCache.markers.get(key);
        if(!m){
          // deterministic point inside the cell
          const baseLat = (i + 0.5) * cell;
          const baseLng = (j + 0.5) * cell;

          // small deterministic jitter inside cell
          const rand = (function(seedStr){
            let h = 2166136261;
            for (let k=0;k<seedStr.length;k++){ h ^= seedStr.charCodeAt(k); h = Math.imul(h, 16777619); }
            return function(){
              h += 0x6D2B79F5;
              let t = Math.imul(h ^ (h >>> 15), 1 | h);
              t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
              return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
          })(key);

          const lat = baseLat + (rand()-0.5) * cell * 0.35;
          const lng = baseLng + (rand()-0.5) * cell * 0.35;

          m = L.circleMarker([lat,lng], { radius: 6, weight: 2, fillOpacity: 0.35 });
          m.bindTooltip(`변전소(가상) [${key}]<br/>용량: ${capText || "확인 필요"}<br/><span style="font-size:11px;color:#64748b;">※ 실제 선로/변전소가 아닌 개념도(모의)</span>`, { sticky:true });
          window.__virtualInfraCache.markers.set(key, m);
        }
        window.virtualInfraLayer.addLayer(m);
      }
    }
  }catch(e){
    console.warn("refreshInfraLayerStable failed", e);
  }
}


window.refreshInfraLayer = refreshInfraLayerStable;

// Hook: only update infra on moveend/zoomend (not on every frame)
(function attachInfraStableHooks(){
  try{
    if (!window.map) return;
    if (window.__infraStableHooksAttached) return;
    window.__infraStableHooksAttached = true;
    let t = null;
    const schedule = (force=false) => {
      clearTimeout(t);
      t = setTimeout(()=>refreshInfraLayerStable(force), 120);
    };
    window.map.on("moveend", ()=>schedule(false));
    window.map.on("zoomend", ()=>schedule(true));
  }catch(e){}
})();


// ---------- (B) 빈곳 클릭 시 주변 설치가능지역 빠른 선택 ----------
function _pointFeature(latlng){
  return { type:"Feature", geometry:{ type:"Point", coordinates:[latlng.lng, latlng.lat] }, properties:{} };
}

function _polyCentroid(feature){
  try { return turf.centroid(feature).geometry.coordinates; } catch(e) { return null; }
}

function _distanceMeters(aLngLat, bLngLat){
  try {
    const from = turf.point(aLngLat);
    const to = turf.point(bLngLat);
    return turf.distance(from,to,{units:"kilometers"}) * 1000.0;
  } catch(e) { return 1e18; }
}

function findNearestCandidateAt(latlng, mode, radiusMeters){
  const list = (window.lastScanCandidates || []);
  if (!list.length) return null;

  const z = window.map?.getZoom?.() ?? 16;
  // 기본은 기존 로직(줌 기반), Mission-1 Smart Click에서는 radiusMeters(예:15m)로 강제
  const r = (typeof radiusMeters === 'number' && isFinite(radiusMeters))
    ? Math.max(0, radiusMeters)
    : Math.max(120, Math.min(520, 520 - z*18)); // ~120-520m
  const pt = _pointFeature(latlng);

  let best = null;
  let bestD = 1e18;

  for (const f of list) {
    if (!f || !f.geometry) continue;
    if (mode && f.properties && f.properties.mode && f.properties.mode !== mode) continue;

    // 1) 내부 클릭이면 즉시 선택
    try{
      if(turf.booleanPointInPolygon(pt, f)) return f;
    }catch(e){}

    // 2) 폴리곤 경계까지 거리(가능하면) 사용
    let d = 1e18;
    try{
      if(typeof turf.pointToPolygonDistance === "function"){
        d = turf.pointToPolygonDistance(pt, f, {units:"kilometers"}) * 1000.0;
      }
    }catch(e){}

    // 3) fallback: centroid 거리
    if(!isFinite(d) || d === 1e18){
      const c = _polyCentroid(f);
      if(!c) continue;
      d = _distanceMeters([latlng.lng, latlng.lat], c);
    }

    if (d < bestD) { bestD = d; best = f; }
  }

  if (best && bestD <= r) return best;
  return null;
}


/* Mission-1: Smart Click loading indicator (instant feedback) */
function _ensureSmartClickLoader(){
  try{
    const mapEl = document.getElementById("map");
    if(!mapEl) return null;
    let el = document.getElementById("smartClickLoading");
    if(el) return el;
    el = document.createElement("div");
    el.id = "smartClickLoading";
    el.style.cssText = "position:absolute; left:50%; top:14px; transform:translateX(-50%); z-index:3500; background:rgba(2,6,23,0.82); color:#fff; padding:8px 12px; border-radius:999px; font-size:12px; display:none; box-shadow:0 10px 25px rgba(0,0,0,0.35); border:1px solid rgba(56,189,248,0.35);";
    el.innerHTML = "<span style='display:inline-flex;align-items:center;gap:8px'><span class='spn' style='width:10px;height:10px;border-radius:999px;border:2px solid rgba(255,255,255,0.35);border-top-color:rgba(56,189,248,1);display:inline-block;animation:spin 0.8s linear infinite'></span><b>검색 중...</b><span style='opacity:.7'>근처 지붕/토지를 자동 선택합니다</span></span>";
    mapEl.appendChild(el);
    // minimal keyframes (once)
    if(!document.getElementById("smartClickSpinStyle")){
      const st=document.createElement("style");
      st.id="smartClickSpinStyle";
      st.innerHTML="@keyframes spin{to{transform:rotate(360deg)}}";
      document.head.appendChild(st);
    }
    return el;
  }catch(e){ return null; }
}
function showSmartClickLoading(on){
  const el = _ensureSmartClickLoader();
  if(!el) return;
  el.style.display = on ? "block" : "none";
}
// When user clicks on map but not on a feature: pick nearest candidate & trigger selection
async function handleBlankMapClick(e){
  const latlng = e?.latlng;
  if (!latlng) return;

  // Mission-1: 즉각 반응(로딩)
  showSmartClickLoading(true);
  const mode = (window.currentMode || window.analysisMode || "roof");

  try{
    // 1) Smart Click: 클릭 지점 기준 15m 반경에서 가장 가까운 폴리곤 자동 선택
    const nearest = findNearestCandidateAt(latlng, mode, 15);
    if (nearest) {
      if (typeof window.onCandidateSelected === "function") {
        window.onCandidateSelected(nearest, {source:"smart-click-15m", latlng});
      } else if (typeof window.renderSelectedRoof === "function") {
        window.renderSelectedRoof(nearest);
      } else if (typeof window.renderSelectedLand === "function") {
        window.renderSelectedLand(nearest);
      }
      return;
    }

    // 2) 후보가 없다면: 클릭 주변만 마이크로 스캔(가능한 경우) 후 다시 15m 탐색
    if (typeof window.scanAtLatLng === "function") {
      await window.scanAtLatLng(latlng);
      const nearest2 = findNearestCandidateAt(latlng, mode, 15);
      if (nearest2) {
        if (typeof window.onCandidateSelected === "function") {
          window.onCandidateSelected(nearest2, {source:"smart-click-after-scan-15m", latlng});
        } else if (typeof window.renderSelectedRoof === "function") {
          window.renderSelectedRoof(nearest2);
        } else if (typeof window.renderSelectedLand === "function") {
          window.renderSelectedLand(nearest2);
        }
        return;
      }
    }

    try{ showToast("근처(15m)에서 선택 가능한 지붕/토지를 찾지 못했습니다"); }catch(_){}
  }catch(err){
    console.warn("handleBlankMapClick failed", err);
  }finally{
    showSmartClickLoading(false);
  }
}

// attach map click handler with guard: don't interfere with existing polygon clicks
(function attachBlankClickHook(){
  try{
    if (!window.map) return;
    if (window.__blankClickAttached) return;
    window.__blankClickAttached = true;
    window.map.on("click", (e)=>{
      // if last click was on feature, skip. Your feature click handler should set this flag.
      if (window.__featureClickLock) { window.__featureClickLock = false; return; }
      handleBlankMapClick(e);
    });
  }catch(e){}
})();

// For feature-click handlers: call this at the start to prevent double-handling
window.markFeatureClicked = function(){ window.__featureClickLock = true; };

</script>


<script>
/* Hardware dropdown binding (Modules/Inverters) */
(function(){
  function el(id){ return document.getElementById(id); }

  const state = { modules: [], inverters: [], selectedModule: null, selectedInverter: null };
  window.spHardware = state; // debug

  async function fetchJson(url){
    const r = await fetch(url, {credentials:"include"});
    const j = await r.json().catch(()=>null);
    if(!j || !j.ok) throw new Error("HTTP " + r.status);
    return j;
  }

  function optionLabelModule(m){
    const p = (m.power_w!=null) ? `${m.power_w}W` : "W 미정";
    const pr = (m.price_won_per_w!=null) ? `${m.price_won_per_w}원/W` : "단가 미정";
    const eff = (m.efficiency_pct!=null) ? `${m.efficiency_pct}%` : "효율 미정";
    const bi = m.is_bifacial ? "양면" : "단면";
    return `${m.no}. ${m.brand} ${m.model} · ${p} · ${pr} · ${eff} · ${bi}`;
  }

  function optionLabelInv(inv){
    const cap = (inv.capacity_kw!=null) ? `${inv.capacity_kw}kW` : "kW 미정";
    const pr = (inv.price_won!=null)
      ? `${Number(inv.price_won).toLocaleString()}원`
      : ((inv.price_million_won!=null) ? `${inv.price_million_won}백만원` : "가격 미정");
    const cb = inv.is_integrated_connection_box ? "접속반일체" : "접속반별도";
    return `${inv.no}. ${inv.brand} ${inv.model} · ${cap} · ${pr} · ${cb}`;
  }

  function applySelected(){
    const m = state.selectedModule;
    if(m){
      const mp = el("modPower");
      const pr = el("modPrice");
      if(mp && m.power_w!=null) mp.value = m.power_w;
      if(pr && m.price_won_per_w!=null) pr.value = m.price_won_per_w;

      const meta = el("moduleMeta");
      if(meta){
        const t = [m.module_type, m.features].filter(Boolean).join(" · ");
        meta.textContent = t;
      }
    }
    const inv = state.selectedInverter;
    if(inv){
      const cap = el("invCap");
      const price = el("invPrice");
      if(cap && inv.capacity_kw!=null) cap.value = inv.capacity_kw;
      if(price){
        if(inv.price_won!=null) price.value = inv.price_won;
        else if(inv.price_million_won!=null) price.value = Math.round(Number(inv.price_million_won) * 1_000_000);
      }

      const meta = el("inverterMeta");
      if(meta){
        const t = [inv.topology, inv.features].filter(Boolean).join(" · ");
        meta.textContent = t;
      }
    }

    try{ if(typeof window.reCalculate === "function") window.reCalculate(); }catch(e){}
  }

  function bindSelect(selectId, items, labelFn, onPick){
    const s = el(selectId);
    if(!s) return;
    s.innerHTML = "";
    const ph = document.createElement("option");
    ph.value = "";
    ph.textContent = "선택...";
    s.appendChild(ph);

    for(const it of items){
      const opt = document.createElement("option");
      opt.value = String(it.no);
      opt.textContent = labelFn(it);
      s.appendChild(opt);
    }

    s.addEventListener("change", ()=>{
      const no = parseInt(s.value || "0", 10);
      const picked = items.find(x => x.no === no) || null;
      onPick(picked);
      applySelected();
    });
  }

  async function initHardwareDropdown(){
    if(!window.BACKEND_URL) return;

    try{
      const mod = await fetchJson(`${BACKEND_URL}/api/hardware/modules`);
      const inv = await fetchJson(`${BACKEND_URL}/api/hardware/inverters`);
      state.modules = Array.isArray(mod.items) ? mod.items : [];
      state.inverters = Array.isArray(inv.items) ? inv.items : [];

      bindSelect("moduleSelect", state.modules, optionLabelModule, (picked)=>{ state.selectedModule = picked; });
      bindSelect("inverterSelect", state.inverters, optionLabelInv, (picked)=>{ state.selectedInverter = picked; });

      // 초기 선택: 현재 입력값과 가장 가까운 모듈
      const curPower = parseFloat(el("modPower")?.value || "0") || 0;
      const curPrice = parseFloat(el("modPrice")?.value || "0") || 0;

      let best = null, bestScore = Infinity;
      for(const m of state.modules){
        if(m.power_w==null || m.price_won_per_w==null) continue;
        const sc = Math.abs(m.power_w - curPower) + Math.abs(m.price_won_per_w - curPrice);
        if(sc < bestScore){ bestScore = sc; best = m; }
      }
      if(!best){
        best = state.modules.find(m => m.power_w!=null && m.price_won_per_w!=null) || null;
      }
      if(best){
        state.selectedModule = best;
        const sel = el("moduleSelect");
        if(sel) sel.value = String(best.no);
      }

      const bestInv = state.inverters.find(i => i.capacity_kw!=null) || state.inverters[0] || null;
      if(bestInv){
        state.selectedInverter = bestInv;
        const sel2 = el("inverterSelect");
        if(sel2) sel2.value = String(bestInv.no);
      }

      applySelected();
    }catch(e){
      try{ console.warn("hardware dropdown init failed:", e); }catch(_){}
    }
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", initHardwareDropdown);
  }else{
    initHardwareDropdown();
  }
})();

// -----------------------------
// Daily API usage counters (VWorld/KEPCO/LAW)
// -----------------------------
async function refreshApiUsage(){
  try{
    if(!window.BACKEND_URL) return;
    const r = await fetch(`${BACKEND_URL}/api/usage`, {credentials:"include"});
    const j = await r.json().catch(()=>null);
    if(!j || !j.ok) return;
    const d = j.data || j;
    if(el("cnt-vworld")) el("cnt-vworld").innerText = String(d.vworld ?? 0);
    if(el("cnt-public")) el("cnt-public").innerText = String(d.kepco ?? 0);
    if(el("cnt-ai")) el("cnt-ai").innerText = String(d.law ?? 0);
  }catch(e){}
}
setInterval(refreshApiUsage, 20000);
setTimeout(refreshApiUsage, 1200);


// ------------------------------
// 설정 모달 열기/닫기 (사이드바 -> 모달)
// ------------------------------
window.openSettingsModal = function() {
  try {
    var modal = document.getElementById("settingsOverlay");
    if (!modal) return;
    modal.classList.remove("hidden");
    if (!modal.classList.contains("flex")) {
      modal.classList.add("flex");
    }
  } catch (e) {
    console.error("openSettingsModal failed", e);
  }
};

window.closeSettingsModal = function() {
  try {
    var modal = document.getElementById("settingsOverlay");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.classList.remove("flex");
  } catch (e) {
    console.error("closeSettingsModal failed", e);
  }
};


// 지붕/토지 모드 전환 (헤더 토글에서 사용)

window.setScanTargetMode = function(mode){
  try{
    // 원본 라디오 버튼 상태 동기화
    var radios = document.querySelectorAll('input[name="scanTarget"]');
    if(radios && radios.length){
      radios.forEach(function(r){
        if(r && r.value === mode){
          r.checked = true;
        }else if(r){
          r.checked = false;
        }
      });
    }

    // 헤더 상단 모드 토글 버튼 시각적 상태 동기화
    var landBtn = document.getElementById("btnModeLand");
    var roofBtn = document.getElementById("btnModeRoof");
    if(landBtn && roofBtn){
      if(mode === "land"){
        landBtn.classList.add("bg-amber-500/20","text-amber-100","border-amber-400");
        landBtn.classList.remove("bg-slate-800/60","text-slate-200","border-slate-600/60");
        roofBtn.classList.add("bg-slate-800/60","text-slate-200","border-slate-600/60");
        roofBtn.classList.remove("bg-amber-500/20","text-amber-100","border-amber-400");
      }else{
        roofBtn.classList.add("bg-amber-500/20","text-amber-100","border-amber-400");
        roofBtn.classList.remove("bg-slate-800/60","text-slate-200","border-slate-600/60");
        landBtn.classList.add("bg-slate-800/60","text-slate-200","border-slate-600/60");
        landBtn.classList.remove("bg-amber-500/20","text-amber-100","border-amber-400");
      }
    }

    // 기존 토글 로직 호출
    if(typeof window.toggleTarget === "function"){
      window.toggleTarget();
    }
  }catch(e){
    console.error("setScanTargetMode failed", e);
  }
};


// 하단 상태 패널 슬라이드 토글

window.toggleBottomStatus = function(){
  try{
    var inner = document.getElementById("bottomStatusInner");
    var icon = document.getElementById("bottomStatusHandleIcon");
    if(!inner) return;
    var isOpen = inner.classList.contains("open");
    if(isOpen){
      inner.classList.remove("open");
      if(icon){ icon.classList.remove("ph-caret-down"); icon.classList.add("ph-caret-up"); }
    }else{
      inner.classList.add("open");
      if(icon){ icon.classList.remove("ph-caret-up"); icon.classList.add("ph-caret-down"); }
    }
  }catch(e){
    console.error("toggleBottomStatus failed", e);
  }
};


// AI 재분석 실행 (정밀 분석 섹션)
window.retryAIAnalysis = function(){
  try{
    if(typeof window.fetchAIData !== "function"){
      showToast("AI 분석 기능을 사용할 수 없습니다");
      return;
    }
    var addr = (window.currentAnalysisData && window.currentAnalysisData.address) || "";
    if(!addr){
      var inp = document.getElementById("addrInput");
      if(inp && inp.value) addr = String(inp.value);
    }
    if(!addr){
      showToast("AI 분석을 위해 주소 정보가 필요합니다");
      return;
    }
    window.fetchAIData(null, null, addr);
    showToast("AI 분석을 다시 실행합니다...");
  }catch(e){
    console.error("retryAIAnalysis failed", e);
    try{ showToast("AI 재분석 중 오류가 발생했습니다"); }catch(_e){}
  }
};

// 레이어 메뉴 토글 (클릭으로 열고 닫기)
window.toggleLayerMenu = function(ev) {
  try {
    if (ev && ev.stopPropagation) ev.stopPropagation();
    var panel = document.getElementById("layerMenuPanel");
    if (!panel) return;
    if (panel.classList.contains("hidden")) {
      panel.classList.remove("hidden");
    } else {
      panel.classList.add("hidden");
    }
  } catch (e) {
    console.error("toggleLayerMenu failed", e);
  }
};

// 바깥 클릭 시 레이어 패널 닫기
document.addEventListener("click", function (ev) {
  try {
    var panel = document.getElementById("layerMenuPanel");
    if (!panel) return;
    // 레이어 버튼 내부 클릭은 무시
    var trigger = ev.target.closest && ev.target.closest("button[onclick*='toggleLayerMenu']");
    if (trigger) return;
    if (!panel.classList.contains("hidden")) {
      panel.classList.add("hidden");
    }
  } catch (e) {
    console.error("global click handler for layerMenuPanel failed", e);
  }
});

// ESC 키로 모달 닫기
document.addEventListener("keydown", function (ev) {
  try {
    if (ev.key === "Escape") {
      window.closeSettingsModal();
    }
  } catch (e) {
    console.error("ESC close modal failed", e);
  }
});

// ------------------------------------------------------------
// 8대 중대 체크사항 요약 패널 연동
// ------------------------------------------------------------
async function fetchEightChecks(){
  try{
    if (typeof currentAnalysisData !== "object" || !currentAnalysisData) return;
    const addr = (currentAnalysisData.address || currentAnalysisData.addr || "").trim();
    const lat = (typeof currentAnalysisData.lat === "number") ? currentAnalysisData.lat : null;
    const lng = (typeof currentAnalysisData.lng === "number") ? currentAnalysisData.lng : null;

    if (!BACKEND_URL) {
      console.warn("8-checks skipped: BACKEND_URL not set");
      return;
    }
    if (!lat || !lng) {
      console.warn("8-checks skipped: lat/lng missing");
      return;
    }

    const payload = {
      address: addr || null,
      lat: lat,
      lng: lng,
      pnu: currentAnalysisData.pnu || null,
      capacity_kw: currentAnalysisData.ac_kw || currentAnalysisData.acKW || null,
      slope_deg: currentAnalysisData.slope_deg || currentAnalysisData.slopeDeg || null,
      sun_hours: currentAnalysisData.sun_hours || currentAnalysisData.sunHours || null,
      dist_road_m: currentAnalysisData.dist_road_m || null,
      dist_substation_m: currentAnalysisData.dist_substation_m || null,
      dist_house_m: currentAnalysisData.dist_house_m || null
    };

    const res = await postJson(`${BACKEND_URL}/api/checks/analyze`, payload);
    if (!res || !res.ok) {
      console.warn("8-checks HTTP error", res && res.status);
      return;
    }
    renderEightChecks(res);
  } catch (e) {
    console.error("fetchEightChecks failed", e);
  }
}

function statusToClass(st){
  if (st === "PASS") return "pass";
  if (st === "FAIL") return "fail";
  return "warn";
}

function renderEightChecks(resp){
  const elc = document.getElementById("aiChecksContainer");
  if (!elc) return;
  const order = [
    ["zoning","용도지역"],
    ["ecology","생태자연도"],
    ["heritage","문화재 규제"],
    ["setback","이격거리"],
    ["grid","한전 여유용량"],
    ["slope","경사도"],
    ["insolation","일사량"],
    ["land_price","토지가격"]
  ];
  const list = (resp && resp.check_list) || {};
  elc.innerHTML = order.map(function(item){
    const k = item[0];
    const title = item[1];
    const it = list[k] || {status:"WARNING", value:"확인 필요", msg:""};
    return `
      <div class="flex items-start justify-between border-b border-slate-700/60 py-1 last:border-b-0 ${statusToClass(it.status)}">
        <div class="text-[11px] text-slate-200 font-semibold mr-2">${title}</div>
        <div class="flex-1 text-right">
          <div class="text-[11px] text-slate-100">${escapeHtml(it.value || "")}</div>
          <div class="text-[10px] text-slate-400">${escapeHtml(it.msg || "")}</div>
        </div>
      </div>
    `;
  }).join("");
}

// escapeHtml이 전역에 없다면 정의
if (typeof escapeHtml !== "function") {
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, function(m){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
    });
  }
}

</script>

</body>
</html
  // -----------------------------
  // Click UX: always show a temporary candidate immediately
  // -----------------------------
  let __tempCandidateLayer = null;
  function drawTemporaryCandidate(lat, lng){
    try{
      if(!window.map) return;
      if(__tempCandidateLayer){
        try{ window.map.removeLayer(__tempCandidateLayer); }catch(e){}
        __tempCandidateLayer = null;
      }
      __tempCandidateLayer = L.circle([lat,lng], { radius: 45, weight: 2, fillOpacity: 0.18 });
      __tempCandidateLayer.addTo(window.map);
    }catch(e){}
  }
>
